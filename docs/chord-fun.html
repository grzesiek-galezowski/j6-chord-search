<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chord Fun</title>
  <style>
    body {
      font-family: monospace;
      margin: 0;
      padding: 20px;
      background: #0f172a;
      color: #e5e7eb;
    }
    .back-link {
      display: inline-block;
      margin-bottom: 16px;
      font-size: 13px;
      color: #38bdf8;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }
    #container {
      font-size: 20px;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
    }
    .status {
      margin-bottom: 10px;
    }
    .piano-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
    }
    canvas {
      border: 1px solid black;
      background: #1e293b;
      max-width: 100%;
      touch-action: none;
    }
    #piano-control {
      width: 100%;
      max-width: 100%;
      height: 20vh;
      min-height: 120px;
    }
    #piano-play {
      width: 100%;
      max-width: 100%;
      height: 20vh;
      min-height: 120px;
    }
    .active-modes {
      color: #38bdf8;
      font-weight: bold;
    }
    .stepper-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .stepper {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .stepper button {
      width: 36px;
      height: 36px;
      background: #1e293b;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .stepper button:active {
      background: #38bdf8;
      color: #0f172a;
    }
    .stepper span {
      min-width: 24px;
      text-align: center;
      font-weight: bold;
    }
    .synth-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
      background: #1e293b;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: #0f172a;
      padding: 10px;
      border-radius: 6px;
      min-width: 200px;
    }
    .control-group h3 {
      margin: 0 0 5px 0;
      font-size: 16px;
      color: #38bdf8;
    }
    .control-group label {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .control-group input[type="range"] {
      width: 80px;
    }
    .control-group input[type="number"], .control-group select {
      width: 100px;
      background: #1e293b;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      padding: 2px 5px;
    }
    .val {
      display: inline-block;
      width: 30px;
      text-align: right;
      font-size: 12px;
      color: #94a3b8;
    }
    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      cursor: pointer;
    }
    #splash-screen h1 {
      color: #38bdf8;
      margin-bottom: 10px;
    }
    #splash-screen p {
      color: #e5e7eb;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      .control-group {
        min-width: 100%;
      }
      .synth-controls {
        gap: 10px;
      }
    }
    .sequencer-section {
      background: #1e293b;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      font-size: 14px;
    }
    .sequencer-section h3 {
      color: #38bdf8;
      margin: 0 0 12px 0;
      font-size: 16px;
    }
    .sequencer-header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }
    .sequencer-header > button {
      padding: 6px 14px;
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      cursor: pointer;
      font-family: monospace;
      font-size: 14px;
    }
    .sequencer-header > button:active {
      background: #38bdf8;
      color: #0f172a;
    }
    #seq-play.active {
      background: #38bdf8;
      color: #0f172a;
    }
    .seq-mode-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .seq-mode-group label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .sequencer-steps {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    @media (min-width: 600px) {
      .sequencer-steps {
        grid-template-columns: repeat(8, 1fr);
      }
    }
    .seq-step {
      background: #0f172a;
      border: 2px solid #334155;
      border-radius: 6px;
      padding: 8px 4px;
      text-align: center;
      cursor: pointer;
      position: relative;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      user-select: none;
    }
    .seq-step.selected {
      border-color: #38bdf8;
    }
    .seq-step.playing {
      border-color: #fbbf24;
      background: #1a1500;
    }
    .seq-step.selected.playing {
      border-color: #f97316;
    }
    .seq-step-num {
      font-size: 10px;
      color: #64748b;
    }
    .seq-step-label {
      font-size: 11px;
      color: #e5e7eb;
      font-weight: bold;
      line-height: 1.3;
    }
    .seq-step-clear {
      position: absolute;
      top: 2px;
      right: 3px;
      width: 14px;
      height: 14px;
      font-size: 12px;
      background: transparent;
      border: none;
      color: #64748b;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }
    .seq-step-clear:hover {
      color: #ef4444;
    }
    .seq-step-empty {
      color: #475569;
      font-size: 18px;
    }
    .seq-vol-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
    }
    #seq-volume {
      width: 80px;
    }
  </style>
</head>
<body>
  <div id="splash-screen">
    <h1>Chord Fun</h1>
    <p>Click anywhere to start</p>
  </div>
  <a href="./index.html" class="back-link">‚Üê Back to Tools</a>
  <div id="container">
    <div class="controls">
      <label>
        Preset:
        <select id="preset-selector">
          <option value="lush-pad">Lush Pad</option>
          <option value="plucky-synth">Plucky Synth</option>
          <option value="dirty-bass">Dirty Bass</option>
          <option value="soft-keys">Soft Keys</option>
          <option value="basic-triangle">Basic Triangle</option>
        </select>
      </label>
    </div>
    <div class="synth-controls">
      <div class="control-group">
        <h3>Oscillator</h3>
        <label>Waveform: 
          <select id="osc-wave">
            <option value="triangle">Triangle</option>
            <option value="sawtooth">Sawtooth</option>
            <option value="square">Square</option>
            <option value="sine">Sine</option>
            <option value="organ">Organ</option>
            <option value="brass">Brass</option>
            <option value="bell">Bell</option>
            <option value="voice">Voice</option>
            <option value="pluck">Pluck</option>
            <option value="soft-saw">Soft Saw</option>
            <option value="hollow-square">Hollow Square</option>
            <option value="metallic">Metallic</option>
            <option value="sub-bass">Sub Bass</option>
            <option value="harmonic-noise">Harmonic Noise</option>
          </select>
        </label>
        <label>Unison Voices: <input type="number" id="unison-voices" value="1" min="1" max="8" /></label>
        <label>Unison Detune: <input type="range" id="unison-detune" value="10" min="0" max="100" /><span class="val">10</span></label>
      </div>
      <div class="control-group">
        <h3>Amp Envelope</h3>
        <label>Attack: <input type="range" id="amp-a" value="10" min="0" max="2000" /><span class="val">10</span></label>
        <label>Decay: <input type="range" id="amp-d" value="100" min="0" max="2000" /><span class="val">100</span></label>
        <label>Sustain: <input type="range" id="amp-s" value="50" min="0" max="100" /><span class="val">50</span></label>
        <label>Release: <input type="range" id="amp-r" value="200" min="0" max="5000" /><span class="val">200</span></label>
      </div>
      <div class="control-group">
        <h3>Ladder Filter</h3>
        <label>Cutoff: <input type="range" id="filt-cutoff" value="2000" min="20" max="20000" /><span class="val">2000</span></label>
        <label>Resonance: <input type="range" id="filt-res" value="1" min="0.1" max="20" step="0.1" /><span class="val">1</span></label>
        <label>Drive: <input type="range" id="filt-drive" value="0" min="0" max="50" /><span class="val">0</span></label>
      </div>
      <div class="control-group">
        <h3>Filter Envelope</h3>
        <label>Amount: <input type="range" id="filt-env-amt" value="0" min="-10000" max="10000" /><span class="val">0</span></label>
        <label>Attack: <input type="range" id="filt-a" value="10" min="0" max="2000" /><span class="val">10</span></label>
        <label>Decay: <input type="range" id="filt-d" value="100" min="0" max="2000" /><span class="val">100</span></label>
        <label>Sustain: <input type="range" id="filt-s" value="50" min="0" max="100" /><span class="val">50</span></label>
        <label>Release: <input type="range" id="filt-r" value="200" min="0" max="5000" /><span class="val">200</span></label>
      </div>
    </div>
    <div class="controls">
      <div class="stepper-group">
        <label>Synth Octave Shift:</label>
        <div class="stepper">
          <button type="button" id="octave-down">-</button>
          <span id="octave-display">0</span>
          <button type="button" id="octave-up">+</button>
        </div>
        <input type="hidden" id="octave-shift" value="0" />
      </div>
      <label>
        Hold Mode:
        <input type="checkbox" id="hold-mode" />
      </label>
      <label>
        Root Doubling (-1 Oct):
        <input type="checkbox" id="root-doubling" checked />
      </label>
      <label>
        Strumming:
        <input type="checkbox" id="strumming" />
      </label>
    </div>
    <div class="status">
      <div>Active Chord Mode: <span id="active-chord" class="active-modes">None</span></div>
      <div>Active Extensions: <span id="active-exts" class="active-modes">None</span></div>
    </div>
    <div class="piano-container">
      <canvas id="piano-control" width="420" height="150"></canvas>
      <canvas id="piano-play" width="630" height="150"></canvas>
    </div>
    <div class="sequencer-section">
      <h3>Chord Sequencer</h3>
      <div class="sequencer-header">
        <div class="stepper">
          <button type="button" id="seq-bpm-down">-</button>
          <span>BPM:&nbsp;<span id="seq-bpm-display">120</span></span>
          <button type="button" id="seq-bpm-up">+</button>
        </div>
        <input type="hidden" id="seq-bpm" value="120" />
        <button type="button" id="seq-play">&#9654; Play</button>
        <button type="button" id="seq-stop">&#9632; Stop</button>
        <button type="button" id="seq-reset">&#8635; Reset</button>
        <div class="seq-mode-group">
          <label><input type="radio" name="seq-mode" value="select" checked /> Select</label>
          <label><input type="radio" name="seq-mode" value="sh101" /> SH-101</label>
        </div>
        <label class="seq-vol-label">
          Vol: <input type="range" id="seq-volume" min="0" max="100" value="70" /><span class="val" id="seq-volume-val">70</span>
        </label>
      </div>
      <div id="sequencer-steps" class="sequencer-steps"></div>
    </div>
  </div>
  <script>
    // Audio Context
    let audioCtx = null;
    const activeOscillators = new Map(); // key: midiNote, value: array of voice objects
    const customWaves = {};
    const distortionCurveCache = new Map();
    const IS_MOBILE = ('ontouchstart' in window || navigator.maxTouchPoints > 0) &&
                      window.matchMedia('(pointer: coarse)').matches;

    function initCustomWaves(ctx) {
      customWaves['organ'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.8, 0.6, 0.1, 0.2, 0.1]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['brass'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['bell'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0, 0, 0.5, 0, 0, 0.2, 0, 0, 0.1]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['voice'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.2, 0.1, 0.05, 0.1, 0.2, 0.05]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['pluck'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.5, 0.25, 0.125, 0.06]),
        new Float32Array([0, 0, 0, 0, 0, 0])
      );
      customWaves['soft-saw'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.5, 0.33, 0.25, 0.2, 0.16, 0.14]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['hollow-square'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0, 0.33, 0, 0.2, 0, 0.14]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['metallic'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.1, 0.8, 0.2, 0.6, 0.3, 0.4]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['sub-bass'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.3, 0.1, 0.05]),
        new Float32Array([0, 0, 0, 0, 0])
      );
      const noiseReal = new Float32Array(32);
      const noiseImag = new Float32Array(32);
      for(let i=1; i<32; i++) {
        noiseReal[i] = Math.random() * (1/i);
      }
      customWaves['harmonic-noise'] = ctx.createPeriodicWave(noiseReal, noiseImag);
    }

    function makeDistortionCurve(amount) {
      const k = typeof amount === 'number' ? amount : 50;
      if (distortionCurveCache.has(k)) return distortionCurveCache.get(k);
      const n_samples = 4096;
      const curve = new Float32Array(n_samples);
      const deg = Math.PI / 180;
      for (let i = 0; i < n_samples; ++i) {
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
      distortionCurveCache.set(k, curve);
      return curve;
    }

    const presets = {
      'lush-pad': {
        wave: 'soft-saw', unisonVoices: 4, unisonDetune: 25,
        ampA: 80, ampD: 1500, ampS: 70, ampR: 2000,
        filtCutoff: 800, filtRes: 2, filtDrive: 5,
        filtEnvAmt: 1500, filtA: 1000, filtD: 2000, filtS: 50, filtR: 2000,
        octaveShift: -1
      },
      'plucky-synth': {
        wave: 'pluck', unisonVoices: 2, unisonDetune: 10,
        ampA: 10, ampD: 500, ampS: 0, ampR: 500,
        filtCutoff: 500, filtRes: 5, filtDrive: 10,
        filtEnvAmt: 4000, filtA: 10, filtD: 300, filtS: 0, filtR: 300,
        octaveShift: 0
      },
      'dirty-bass': {
        wave: 'sawtooth', unisonVoices: 3, unisonDetune: 15,
        ampA: 20, ampD: 800, ampS: 40, ampR: 400,
        filtCutoff: 200, filtRes: 8, filtDrive: 30,
        filtEnvAmt: 2000, filtA: 20, filtD: 500, filtS: 20, filtR: 400,
        octaveShift: -2
      },
      'soft-keys': {
        wave: 'sine', unisonVoices: 1, unisonDetune: 0,
        ampA: 50, ampD: 1000, ampS: 30, ampR: 1000,
        filtCutoff: 1200, filtRes: 1, filtDrive: 0,
        filtEnvAmt: 500, filtA: 50, filtD: 800, filtS: 30, filtR: 1000,
        octaveShift: 0
      },
      'basic-triangle': {
        wave: 'triangle', unisonVoices: 1, unisonDetune: 10,
        ampA: 10, ampD: 100, ampS: 50, ampR: 200,
        filtCutoff: 2000, filtRes: 1, filtDrive: 0,
        filtEnvAmt: 0, filtA: 10, filtD: 100, filtS: 50, filtR: 200,
        octaveShift: 0
      }
    };

    function applyPreset(presetName) {
      const p = presets[presetName];
      if (!p) return;

      document.getElementById('osc-wave').value = p.wave;
      document.getElementById('unison-voices').value = p.unisonVoices;

      const octShift = p.octaveShift !== undefined ? p.octaveShift : 0;
      document.getElementById('octave-shift').value = octShift;
      const octDisplay = document.getElementById('octave-display');
      if (octDisplay) octDisplay.innerText = octShift;

      const setRange = (id, val) => {
        const el = document.getElementById(id);
        el.value = val;
        const span = el.nextElementSibling;
        if (span && span.classList.contains('val')) span.innerText = val;
      };

      setRange('unison-detune', p.unisonDetune);
      setRange('amp-a', p.ampA);
      setRange('amp-d', p.ampD);
      setRange('amp-s', p.ampS);
      setRange('amp-r', p.ampR);
      setRange('filt-cutoff', p.filtCutoff);
      setRange('filt-res', p.filtRes);
      setRange('filt-drive', p.filtDrive);
      setRange('filt-env-amt', p.filtEnvAmt);
      setRange('filt-a', p.filtA);
      setRange('filt-d', p.filtD);
      setRange('filt-s', p.filtS);
      setRange('filt-r', p.filtR);
    }

    document.getElementById('preset-selector').addEventListener('change', (e) => {
      applyPreset(e.target.value);
    });

    document.getElementById('octave-down').addEventListener('click', () => {
      const input = document.getElementById('octave-shift');
      let val = parseInt(input.value) || 0;
      if (val > -3) {
        val--;
        input.value = val;
        document.getElementById('octave-display').innerText = val;
      }
    });

    document.getElementById('octave-up').addEventListener('click', () => {
      const input = document.getElementById('octave-shift');
      let val = parseInt(input.value) || 0;
      if (val < 3) {
        val++;
        input.value = val;
        document.getElementById('octave-display').innerText = val;
      }
    });

    // Apply default preset on load
    applyPreset('lush-pad');

    function getSynthParams() {
      return {
        wave: document.getElementById('osc-wave').value,
        unisonVoices: parseInt(document.getElementById('unison-voices').value),
        unisonDetune: parseFloat(document.getElementById('unison-detune').value),
        ampA: parseFloat(document.getElementById('amp-a').value) / 1000,
        ampD: parseFloat(document.getElementById('amp-d').value) / 1000,
        ampS: parseFloat(document.getElementById('amp-s').value) / 100,
        ampR: parseFloat(document.getElementById('amp-r').value) / 1000,
        filtCutoff: parseFloat(document.getElementById('filt-cutoff').value),
        filtRes: parseFloat(document.getElementById('filt-res').value),
        filtDrive: parseFloat(document.getElementById('filt-drive').value),
        filtEnvAmt: parseFloat(document.getElementById('filt-env-amt').value),
        filtA: parseFloat(document.getElementById('filt-a').value) / 1000,
        filtD: parseFloat(document.getElementById('filt-d').value) / 1000,
        filtS: parseFloat(document.getElementById('filt-s').value) / 100,
        filtR: parseFloat(document.getElementById('filt-r').value) / 1000,
      };
    }

    function initAudio() {
      if (!audioCtx) {
        const ctxOptions = IS_MOBILE ? { sampleRate: 22050 } : {};
        audioCtx = new (window.AudioContext || window.webkitAudioContext)(ctxOptions);
        initCustomWaves(audioCtx);
        seqOutputGain = audioCtx.createGain();
        seqOutputGain.gain.value = parseInt(document.getElementById('seq-volume').value) / 100;
        seqOutputGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    document.getElementById('splash-screen').addEventListener('click', (e) => {
      initAudio();
      e.currentTarget.style.display = 'none';
    });

    document.querySelectorAll('input[type="range"]').forEach(input => {
      input.addEventListener('input', (e) => {
        const span = e.target.nextElementSibling;
        if (span && span.classList.contains('val')) {
          span.innerText = e.target.value;
        }
      });
    });

    function midiToFreq(midiNote) {
      return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    function playFreqs(midiNote, freqs, destination = null, scheduleOffset = 0) {
      if (!audioCtx) return;
      const dest = destination || audioCtx.destination;
      const params = getSynthParams();
      const now = audioCtx.currentTime + scheduleOffset;
      const isStrumming = document.getElementById('strumming').checked;
      const strumDelay = isStrumming ? 0.03 : 0; // 30ms delay per note

      const voiceNodes = [];
      const maxGain = 0.5 / Math.max(1, Math.sqrt(freqs.length * params.unisonVoices));

      freqs.forEach((freq, index) => {
        const noteStartTime = now + (index * strumDelay);

        const driveNode = audioCtx.createWaveShaper();
        driveNode.curve = makeDistortionCurve(params.filtDrive);
        driveNode.oversample = IS_MOBILE ? 'none' : '4x';

        const filter1 = audioCtx.createBiquadFilter();
        filter1.type = 'lowpass';
        filter1.Q.value = params.filtRes;

        const filter2 = audioCtx.createBiquadFilter();
        filter2.type = 'lowpass';
        filter2.Q.value = params.filtRes;

        const ampNode = audioCtx.createGain();
        ampNode.gain.value = 0;

        driveNode.connect(filter1);
        filter1.connect(filter2);
        filter2.connect(ampNode);
        ampNode.connect(dest);

        ampNode.gain.setValueAtTime(0, noteStartTime);
        ampNode.gain.linearRampToValueAtTime(maxGain, noteStartTime + params.ampA);
        ampNode.gain.exponentialRampToValueAtTime(Math.max(0.0001, maxGain * params.ampS), noteStartTime + params.ampA + params.ampD);

        const baseCutoff = params.filtCutoff;
        const peakCutoff = Math.max(20, Math.min(20000, baseCutoff + params.filtEnvAmt));
        const sustainCutoff = Math.max(20, Math.min(20000, baseCutoff + params.filtEnvAmt * params.filtS));

        [filter1, filter2].forEach(f => {
          f.frequency.setValueAtTime(baseCutoff, noteStartTime);
          f.frequency.linearRampToValueAtTime(peakCutoff, noteStartTime + params.filtA);
          f.frequency.exponentialRampToValueAtTime(Math.max(20, sustainCutoff), noteStartTime + params.filtA + params.filtD);
        });

        const oscs = [];
        for (let i = 0; i < params.unisonVoices; i++) {
          const osc = audioCtx.createOscillator();

          if (['sine', 'square', 'sawtooth', 'triangle'].includes(params.wave)) {
            osc.type = params.wave;
          } else {
            osc.setPeriodicWave(customWaves[params.wave]);
          }

          let detune = 0;
          if (params.unisonVoices > 1) {
            const spread = params.unisonDetune;
            detune = (i / (params.unisonVoices - 1)) * spread * 2 - spread;
          }
          osc.frequency.value = freq;
          osc.detune.value = detune;

          osc.connect(driveNode);
          osc.start(noteStartTime);
          oscs.push(osc);
        }

        voiceNodes.push({ oscs, ampNode, filter1, filter2, params });
      });

      activeOscillators.set(midiNote, voiceNodes);
    }

    function stopFreqs(midiNote) {
      if (activeOscillators.has(midiNote)) {
        const voiceNodes = activeOscillators.get(midiNote);
        const now = audioCtx.currentTime;

        voiceNodes.forEach(voice => {
          const { oscs, ampNode, filter1, filter2, params } = voice;

          ampNode.gain.cancelScheduledValues(now);
          ampNode.gain.setValueAtTime(ampNode.gain.value, now);
          ampNode.gain.exponentialRampToValueAtTime(0.0001, now + params.ampR);

          const baseCutoff = params.filtCutoff;
          filter1.frequency.cancelScheduledValues(now);
          filter1.frequency.setValueAtTime(filter1.frequency.value, now);
          filter1.frequency.exponentialRampToValueAtTime(Math.max(20, baseCutoff), now + params.filtR);

          filter2.frequency.cancelScheduledValues(now);
          filter2.frequency.setValueAtTime(filter2.frequency.value, now);
          filter2.frequency.exponentialRampToValueAtTime(Math.max(20, baseCutoff), now + params.filtR);

          oscs.forEach(osc => {
            osc.stop(now + params.ampR + 0.1);
          });

          setTimeout(() => {
            oscs.forEach(osc => osc.disconnect());
            ampNode.disconnect();
          }, (params.ampR + 0.2) * 1000);
        });

        activeOscillators.delete(midiNote);
      }
    }

    // State
    const pressedNotes = new Set();
    const controlOctaveBase = 48; // C2
    
    // Control mappings
    const chordModes = {
      48: { name: 'Major', intervals: [0, 4, 7], guitarVoicing: [0, 7, 12, 16, 19, 24] },
      49: { name: 'Diminished', intervals: [0, 3, 6], guitarVoicing: [0, 6, 12, 15, 18, 24] },
      50: { name: 'Minor', intervals: [0, 3, 7], guitarVoicing: [0, 7, 12, 15, 19, 24] },
      51: { name: 'Suspended', intervals: [0, 5, 7], guitarVoicing: [0, 7, 12, 17, 19, 24] }
    };

    const chordInversions = {
      52: { name: 'Inv1', indexToRaise: 0 }, // E2
      53: { name: 'Inv2', indexToRaise: 1 }  // F2
    };

    const chordExtensions = {
      54: { name: '6', interval: 9 },   // F#2
      55: { name: 'm7', interval: 10 }, // G2
      56: { name: 'M7', interval: 11 }, // G#2
      57: { name: '9', interval: 14 }   // A2
    };

    let activeChordMode = null;
    const activeExtensions = new Set();
    const activeInversions = new Set();

    let latchedChordMode = null;
    const latchedExtensions = new Set();
    const latchedInversions = new Set();

    document.getElementById('hold-mode').addEventListener('change', (e) => {
      if (e.target.checked) {
        latchedChordMode = activeChordMode;
        latchedExtensions.clear();
        activeExtensions.forEach(ext => latchedExtensions.add(ext));
        latchedInversions.clear();
        activeInversions.forEach(inv => latchedInversions.add(inv));
      }
      updateState();
    });

    function updateState() {
      const isHold = document.getElementById('hold-mode').checked;

      if (!isHold) {
        activeChordMode = null;
        for (let key in chordModes) {
          if (pressedNotes.has(parseInt(key))) {
            activeChordMode = chordModes[key];
            break; // Only one active at a time
          }
        }

        activeExtensions.clear();
        for (let key in chordExtensions) {
          if (pressedNotes.has(parseInt(key))) {
            activeExtensions.add(chordExtensions[key]);
          }
        }

        activeInversions.clear();
        for (let key in chordInversions) {
          if (pressedNotes.has(parseInt(key))) {
            activeInversions.add(chordInversions[key]);
          }
        }
      } else {
        activeChordMode = latchedChordMode;
        activeExtensions.clear();
        latchedExtensions.forEach(e => activeExtensions.add(e));
        activeInversions.clear();
        latchedInversions.forEach(e => activeInversions.add(e));
      }

      document.getElementById('active-chord').innerText = activeChordMode ? activeChordMode.name : 'None';

      const exts = Array.from(activeExtensions).map(e => e.name);
      const invs = Array.from(activeInversions).map(e => e.name);
      const combined = [...exts, ...invs];

      document.getElementById('active-exts').innerText = combined.length > 0 
        ? combined.join(', ') 
        : 'None';

      drawPiano();
    }

    function getChordIntervals() {
      if (!activeChordMode) return [0];

      const isStrumming = document.getElementById('strumming').checked;
      let intervals = [];

      if (isStrumming && activeChordMode.guitarVoicing) {
        intervals = [...activeChordMode.guitarVoicing];
      } else {
        intervals = [...activeChordMode.intervals];
      }

      activeExtensions.forEach(ext => {
        // For guitar voicings, we might want to adjust extensions to fit, but for now just add them
        // usually extensions are added higher up
        let extInterval = ext.interval;
        if (isStrumming) {
           // push extensions up an octave to fit above the basic guitar voicing
           extInterval += 12;
        }
        intervals.push(extInterval);
      });

      // Apply inversions
      intervals.sort((a, b) => a - b);

      activeInversions.forEach(inv => {
        if (inv.indexToRaise < intervals.length) {
          intervals[inv.indexToRaise] += 12;
        }
      });

      // Add root doubling after inversions so it's not affected
      const isRootDoubling = document.getElementById('root-doubling').checked;
      if (isRootDoubling && !isStrumming) {
        intervals.push(-12);
      }

      return intervals;
    }

    // Piano drawing setup
    const canvasControl = document.getElementById('piano-control');
    const ctxControl = canvasControl.getContext('2d');
    const canvasPlay = document.getElementById('piano-play');
    const ctxPlay = canvasPlay.getContext('2d');

    const startNoteControl = 48; // C2
    const endNoteControl = 59;   // B2 (1 octave)
    const startNotePlay = 60;    // C3
    const endNotePlay = 83;      // B4 (2 octaves)

    // Base dimensions for drawing logic (will scale via CSS)
    const whiteKeyWidthControl = 60; // Wider for control
    const blackKeyWidthControl = 36;
    const blackKeyHeightControl = 90;
    const whiteKeyHeightControl = 150;
    const blackOffsetsControl = [60, 120, 240, 300, 360]; // Centers for C#, D#, F#, G#, A#

    const whiteKeyWidthPlay = 45; // Wider than original, but less than control
    const blackKeyWidthPlay = 27;
    const blackKeyHeightPlay = 90;
    const whiteKeyHeightPlay = 150;
    const blackOffsetsPlay = [45, 90, 180, 225, 270]; // Centers for C#, D#, F#, G#, A#

    function resizeCanvas(canvas, logicalWidth, logicalHeight) {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // Set actual size in memory (scaled to account for extra pixel density)
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      // Normalize coordinate system to use css pixels
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      // Scale to fit the logical dimensions into the actual dimensions
      const scaleX = rect.width / logicalWidth;
      const scaleY = rect.height / logicalHeight;
      ctx.scale(scaleX, scaleY);
    }

    let canvasNeedsResize = true;

    function drawPiano() {
      if (canvasNeedsResize) {
        resizeCanvas(canvasControl, 420, 150);
        resizeCanvas(canvasPlay, 630, 150);
        canvasNeedsResize = false;
      }

      // Draw Control Piano
      ctxControl.clearRect(0, 0, 420, 150);

      // Draw white keys (7 keys for 1 octave)
      for (let i = 0; i < 7; i++) {
        const x = i * whiteKeyWidthControl;
        const noteOffset = [0, 2, 4, 5, 7, 9, 11][i];
        const note = startNoteControl + noteOffset;

        let isActiveControl = false;
        if (chordModes[note] && activeChordMode === chordModes[note]) isActiveControl = true;
        if (chordExtensions[note] && activeExtensions.has(chordExtensions[note])) isActiveControl = true;
        if (chordInversions[note] && activeInversions.has(chordInversions[note])) isActiveControl = true;

        ctxControl.fillStyle = (pressedNotes.has(note) || isActiveControl) ? 'yellow' : '#e2e8f0';
        ctxControl.fillRect(x, 0, whiteKeyWidthControl, whiteKeyHeightControl);
        ctxControl.strokeRect(x, 0, whiteKeyWidthControl, whiteKeyHeightControl);

        // Label control keys
        ctxControl.fillStyle = 'black';
        ctxControl.font = '14px monospace';
        if (chordModes[note]) {
          ctxControl.fillText(chordModes[note].name.substring(0, 3), x + 5, whiteKeyHeightControl - 15);
        } else if (chordExtensions[note]) {
          ctxControl.fillText(chordExtensions[note].name, x + 10, whiteKeyHeightControl - 15);
        } else if (chordInversions[note]) {
          ctxControl.fillText(chordInversions[note].name, x + 5, whiteKeyHeightControl - 15);
        }
      }

      // Draw black keys (5 keys for 1 octave)
      const blackNotesControl = [1, 3, 6, 8, 10];
      for (let i = 0; i < 5; i++) {
        const note = startNoteControl + blackNotesControl[i];
        const x = blackOffsetsControl[i] - blackKeyWidthControl / 2;

        let isActiveControl = false;
        if (chordModes[note] && activeChordMode === chordModes[note]) isActiveControl = true;
        if (chordExtensions[note] && activeExtensions.has(chordExtensions[note])) isActiveControl = true;
        if (chordInversions[note] && activeInversions.has(chordInversions[note])) isActiveControl = true;

        ctxControl.fillStyle = (pressedNotes.has(note) || isActiveControl) ? 'yellow' : 'black';
        ctxControl.fillRect(x, 0, blackKeyWidthControl, blackKeyHeightControl);

        // Label control keys
        ctxControl.fillStyle = 'white';
        ctxControl.font = '12px monospace';
        if (chordModes[note]) {
          ctxControl.fillText(chordModes[note].name.substring(0, 3), x + 2, blackKeyHeightControl - 15);
        } else if (chordExtensions[note]) {
          ctxControl.fillText(chordExtensions[note].name, x + 5, blackKeyHeightControl - 15);
        } else if (chordInversions[note]) {
          ctxControl.fillText(chordInversions[note].name, x + 2, blackKeyHeightControl - 15);
        }
      }

      // Draw Play Piano
      ctxPlay.clearRect(0, 0, 630, 150);

      // Draw white keys (14 keys for 2 octaves)
      for (let i = 0; i < 14; i++) {
        const x = i * whiteKeyWidthPlay;
        const octave = Math.floor(i / 7);
        const noteIndex = i % 7;
        const noteOffset = [0, 2, 4, 5, 7, 9, 11][noteIndex];
        const note = startNotePlay + octave * 12 + noteOffset;

        if (note <= endNotePlay) {
          ctxPlay.fillStyle = pressedNotes.has(note) ? 'yellow' : 'white';
          ctxPlay.fillRect(x, 0, whiteKeyWidthPlay, whiteKeyHeightPlay);
          ctxPlay.strokeRect(x, 0, whiteKeyWidthPlay, whiteKeyHeightPlay);
        }
      }

      // Draw black keys (10 keys, 5 per octave for 2 octaves)
      for (let octave = 0; octave < 2; octave++) {
        const startX = (octave * 7 * whiteKeyWidthPlay);
        const blackNotesPlay = [1, 3, 6, 8, 10];
        for (let i = 0; i < 5; i++) {
          const note = startNotePlay + octave * 12 + blackNotesPlay[i];
          if (note <= endNotePlay) {
            const x = startX + blackOffsetsPlay[i] - blackKeyWidthPlay / 2;
            ctxPlay.fillStyle = pressedNotes.has(note) ? 'yellow' : 'black';
            ctxPlay.fillRect(x, 0, blackKeyWidthPlay, blackKeyHeightPlay);
          }
        }
      }
    }

    // MIDI setup
    if (navigator.requestMIDIAccess) {
      navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
    }

    function onMIDISuccess(midiAccess) {
      const inputs = midiAccess.inputs.values();
      for (let input of inputs) {
        input.onmidimessage = handleMIDIMessage;
      }
      drawPiano();
    }

    function onMIDIFailure() {
      console.error('Failed to access MIDI devices.');
    }

    function handleMIDIMessage(event) {
      const message = event.data;
      const type = message[0];
      const note = message[1];
      const velocity = message[2];
      
      if (type >= 144 && type <= 159 && velocity > 0) {
        noteOn(note);
      } else if ((type >= 128 && type <= 143) || (type >= 144 && type <= 159 && velocity === 0)) {
        noteOff(note);
      }
    }

    function noteOn(note) {
      initAudio();
      pressedNotes.add(note);

      if (note < controlOctaveBase + 12) {
        const isHold = document.getElementById('hold-mode').checked;
        if (isHold) {
          if (chordModes[note]) {
            if (latchedChordMode === chordModes[note]) {
              latchedChordMode = null;
            } else {
              latchedChordMode = chordModes[note];
            }
          } else if (chordExtensions[note]) {
            if (latchedExtensions.has(chordExtensions[note])) {
              latchedExtensions.delete(chordExtensions[note]);
            } else {
              latchedExtensions.add(chordExtensions[note]);
            }
          } else if (chordInversions[note]) {
            if (latchedInversions.has(chordInversions[note])) {
              latchedInversions.delete(chordInversions[note]);
            } else {
              latchedInversions.add(chordInversions[note]);
            }
          }
        }
      }

      updateState();

      // If it's a playing note (above control octave)
      if (note >= controlOctaveBase + 12) {
        const shift = parseInt(document.getElementById('octave-shift').value) || 0;
        const baseNote = note + (shift * 12);
        const intervals = getChordIntervals();
        const freqs = intervals.map(interval => midiToFreq(baseNote + interval));
        playFreqs(note, freqs);

        if (!seqPlaying) {
          seqRecordToStep(seqSelectedStep, note);
          if (document.querySelector('input[name="seq-mode"]:checked').value === 'sh101') {
            seqAdvanceToNextStep();
          }
        }
      }
    }

    function noteOff(note) {
      pressedNotes.delete(note);
      updateState();
      
      if (note >= controlOctaveBase + 12) {
        stopFreqs(note);
      } else {
        // If a control key is released, we might want to update currently playing chords?
        // For simplicity, we only apply chord modes at the moment of noteOn.
      }
    }

    // Mouse interaction for piano
    function setupMouseEvents(canvas, isControl) {
      const logicalWidth = isControl ? 420 : 630;
      const logicalHeight = 150;

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = logicalWidth / rect.width;
        const scaleY = logicalHeight / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        const note = getNoteFromPos(x, y, isControl);
        if (note !== null) {
          noteOn(note);
          canvas.dataset.activeNote = note;
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        const note = parseInt(canvas.dataset.activeNote);
        if (!isNaN(note)) {
          noteOff(note);
          delete canvas.dataset.activeNote;
        }
      });

      canvas.addEventListener('mouseleave', (e) => {
        const note = parseInt(canvas.dataset.activeNote);
        if (!isNaN(note)) {
          noteOff(note);
          delete canvas.dataset.activeNote;
        }
      });
    }

    setupMouseEvents(canvasControl, true);
    setupMouseEvents(canvasPlay, false);

    // Touch interaction for piano
    function setupTouchEvents(canvas, isControl) {
      const activeTouches = new Map();
      const logicalWidth = isControl ? 420 : 630;
      const logicalHeight = 150;

      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = logicalWidth / rect.width;
        const scaleY = logicalHeight / rect.height;

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.target !== canvas) continue;
          const x = (touch.clientX - rect.left) * scaleX;
          const y = (touch.clientY - rect.top) * scaleY;
          const note = getNoteFromPos(x, y, isControl);
          if (note !== null) {
            noteOn(note);
            activeTouches.set(touch.identifier, note);
          }
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = logicalWidth / rect.width;
        const scaleY = logicalHeight / rect.height;

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.target !== canvas) continue;
          const x = (touch.clientX - rect.left) * scaleX;
          const y = (touch.clientY - rect.top) * scaleY;
          const currentNote = getNoteFromPos(x, y, isControl);
          const prevNote = activeTouches.get(touch.identifier);

          if (currentNote !== prevNote) {
            if (prevNote !== undefined && prevNote !== null) {
              noteOff(prevNote);
            }
            if (currentNote !== null) {
              noteOn(currentNote);
              activeTouches.set(touch.identifier, currentNote);
            } else {
              activeTouches.delete(touch.identifier);
            }
          }
        }
      }, { passive: false });

      const handleTouchEnd = (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.target !== canvas) continue;
          const note = activeTouches.get(touch.identifier);
          if (note !== undefined && note !== null) {
            noteOff(note);
            activeTouches.delete(touch.identifier);
          }
        }
      };

      canvas.addEventListener('touchend', handleTouchEnd);
      canvas.addEventListener('touchcancel', handleTouchEnd);
    }

    setupTouchEvents(canvasControl, true);
    setupTouchEvents(canvasPlay, false);

    // QWERTY Keyboard setup
    const keyToNote = {
      // Control octave
      'z': 48, 's': 49, 'x': 50, 'd': 51, 'c': 52, 'v': 53,
      'g': 54, 'b': 55, 'h': 56, 'n': 57, 'j': 58, 'm': 59,
      // Upper octaves
      'q': 60, '2': 61, 'w': 62, '3': 63, 'e': 64, 'r': 65,
      '5': 66, 't': 67, '6': 68, 'y': 69, '7': 70, 'u': 71,
      'i': 72, '9': 73, 'o': 74, '0': 75, 'p': 76, '[': 77,
      '=': 78, ']': 79
    };

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      const key = e.key.toLowerCase();
      if (keyToNote[key] !== undefined) {
        noteOn(keyToNote[key]);
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      const key = e.key.toLowerCase();
      if (keyToNote[key] !== undefined) {
        noteOff(keyToNote[key]);
      }
    });

    function getNoteFromPos(x, y, isControl) {
      if (x < 0 || y < 0) return null;

      if (isControl) {
        if (x > 420 || y > 150) return null;
        // Check black keys first
        const blackNotesControl = [1, 3, 6, 8, 10];
        for (let i = 0; i < 5; i++) {
          const bx = blackOffsetsControl[i] - blackKeyWidthControl / 2;
          if (x >= bx && x <= bx + blackKeyWidthControl && y <= blackKeyHeightControl) {
            return startNoteControl + blackNotesControl[i];
          }
        }
        // Check white keys
        const whiteIndex = Math.floor(x / whiteKeyWidthControl);
        if (whiteIndex >= 0 && whiteIndex < 7) {
          const noteOffset = [0, 2, 4, 5, 7, 9, 11][whiteIndex];
          return startNoteControl + noteOffset;
        }
      } else {
        if (x > 630 || y > 150) return null;
        // Check black keys first
        for (let octave = 0; octave < 2; octave++) {
          const startX = (octave * 7 * whiteKeyWidthPlay);
          const blackNotesPlay = [1, 3, 6, 8, 10];
          for (let i = 0; i < 5; i++) {
            const bx = startX + blackOffsetsPlay[i] - blackKeyWidthPlay / 2;
            if (x >= bx && x <= bx + blackKeyWidthPlay && y <= blackKeyHeightPlay) {
              return startNotePlay + octave * 12 + blackNotesPlay[i];
            }
          }
        }
        // Check white keys
        const whiteIndex = Math.floor(x / whiteKeyWidthPlay);
        if (whiteIndex >= 0 && whiteIndex < 14) {
          const octave = Math.floor(whiteIndex / 7);
          const noteIndex = whiteIndex % 7;
          const noteOffset = [0, 2, 4, 5, 7, 9, 11][noteIndex];
          return startNotePlay + octave * 12 + noteOffset;
        }
      }
      return null;
    }

    window.addEventListener('resize', () => {
      canvasNeedsResize = true;
      drawPiano();
    });

    // === CHORD SEQUENCER ===
    const SEQ_STEPS = 8;
    const SEQ_KEY = 'seq';
    const sequencerSteps = Array(SEQ_STEPS).fill(null);
    let seqSelectedStep = 0;
    let seqCurrentStep = -1;
    let seqIntervalId = null;
    let seqPlaying = false;
    let seqCurrentFreqs = null;
    let seqOutputGain = null;

    function buildChordLabel(rootNote, chordMode, extensions, inversions) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const noteName = noteNames[rootNote % 12];
      const parts = [noteName];
      if (chordMode) parts.push(chordMode.name.substring(0, 3));
      if (extensions && extensions.size > 0) {
        parts.push(Array.from(extensions).map(e => e.name).join('+'));
      }
      if (inversions && inversions.size > 0) {
        parts.push(Array.from(inversions).map(e => e.name).join('+'));
      }
      return parts.join(' ');
    }

    function freqsMatch(a, b) {
      if (!a && !b) return true;
      if (!a || !b) return false;
      if (a.length !== b.length) return false;
      return a.every((f, i) => Math.abs(f - b[i]) < 0.01);
    }

    function seqRecordToStep(stepIndex, rootNote) {
      const shift = parseInt(document.getElementById('octave-shift').value) || 0;
      const baseNote = rootNote + (shift * 12);
      const intervals = getChordIntervals();
      const freqs = intervals.map(interval => midiToFreq(baseNote + interval));
      const label = buildChordLabel(rootNote, activeChordMode, activeExtensions, activeInversions);
      sequencerSteps[stepIndex] = { rootNote, label, freqs };
      seqRefreshStep(stepIndex);
    }

    function seqAdvanceToNextStep() {
      seqSelectedStep = (seqSelectedStep + 1) % SEQ_STEPS;
      seqRefreshAllClasses();
    }

    function seqGetBarMs() {
      const bpm = parseInt(document.getElementById('seq-bpm').value) || 120;
      return (4 * 60 * 1000) / bpm;
    }

    function seqPlayStep(stepIndex) {
      const step = sequencerSteps[stepIndex];
      seqCurrentStep = stepIndex;
      if (step !== null) {
        if (!freqsMatch(step.freqs, seqCurrentFreqs)) {
          if (seqCurrentFreqs !== null) {
            stopFreqs(SEQ_KEY);
          }
          playFreqs(SEQ_KEY, step.freqs, seqOutputGain, 0.05);
          seqCurrentFreqs = step.freqs;
        }
        // same chord: sustain, do nothing
      } else {
        if (seqCurrentFreqs !== null) {
          stopFreqs(SEQ_KEY);
          seqCurrentFreqs = null;
        }
      }
      seqRefreshAllClasses();
    }

    function seqRestartInterval() {
      if (seqIntervalId) clearInterval(seqIntervalId);
      seqIntervalId = setInterval(() => {
        seqCurrentStep = (seqCurrentStep + 1) % SEQ_STEPS;
        seqPlayStep(seqCurrentStep);
      }, seqGetBarMs());
    }

    function seqStart() {
      if (seqPlaying) return;
      initAudio();
      seqPlaying = true;
      seqCurrentStep = 0;
      seqCurrentFreqs = null;
      seqPlayStep(0);
      seqRestartInterval();
      document.getElementById('seq-play').classList.add('active');
    }

    function seqStop() {
      if (!seqPlaying) return;
      clearInterval(seqIntervalId);
      seqIntervalId = null;
      seqPlaying = false;
      if (seqCurrentFreqs !== null) {
        stopFreqs(SEQ_KEY);
        seqCurrentFreqs = null;
      }
      seqCurrentStep = -1;
      document.getElementById('seq-play').classList.remove('active');
      seqRefreshAllClasses();
    }

    function seqReset() {
      seqStop();
      for (let i = 0; i < SEQ_STEPS; i++) {
        sequencerSteps[i] = null;
      }
      seqSelectedStep = 0;
      drawSequencer();
    }

    const seqStepEls = [];

    function initSequencerDOM() {
      const container = document.getElementById('sequencer-steps');
      container.innerHTML = '';
      seqStepEls.length = 0;
      for (let i = 0; i < SEQ_STEPS; i++) {
        const div = document.createElement('div');
        div.className = 'seq-step';

        const numSpan = document.createElement('span');
        numSpan.className = 'seq-step-num';
        numSpan.textContent = i + 1;
        div.appendChild(numSpan);

        const content = document.createElement('span');
        div.appendChild(content);

        const clearBtn = document.createElement('button');
        clearBtn.className = 'seq-step-clear';
        clearBtn.textContent = '\u00d7';
        clearBtn.title = 'Clear step';
        clearBtn.style.display = 'none';
        clearBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          sequencerSteps[i] = null;
          seqRefreshStep(i);
        });
        div.appendChild(clearBtn);

        div.addEventListener('click', () => {
          seqSelectedStep = i;
          seqRefreshAllClasses();
        });

        container.appendChild(div);
        seqStepEls.push({ div, content, clearBtn });
      }
    }

    function seqRefreshStep(i) {
      if (seqStepEls.length === 0) return;
      const { div, content, clearBtn } = seqStepEls[i];
      div.classList.toggle('selected', i === seqSelectedStep);
      div.classList.toggle('playing', seqPlaying && i === seqCurrentStep);
      const step = sequencerSteps[i];
      if (step) {
        content.className = 'seq-step-label';
        content.textContent = step.label;
        clearBtn.style.display = '';
      } else {
        content.className = 'seq-step-empty';
        content.textContent = '\u2013';
        clearBtn.style.display = 'none';
      }
    }

    function seqRefreshAllClasses() {
      if (seqStepEls.length === 0) return;
      for (let i = 0; i < SEQ_STEPS; i++) {
        const { div } = seqStepEls[i];
        div.classList.toggle('selected', i === seqSelectedStep);
        div.classList.toggle('playing', seqPlaying && i === seqCurrentStep);
      }
    }

    function drawSequencer() {
      if (seqStepEls.length === 0) initSequencerDOM();
      for (let i = 0; i < SEQ_STEPS; i++) {
        seqRefreshStep(i);
      }
    }

    document.getElementById('seq-bpm-down').addEventListener('click', () => {
      const input = document.getElementById('seq-bpm');
      let val = parseInt(input.value) || 120;
      val = Math.max(20, val - 5);
      input.value = val;
      document.getElementById('seq-bpm-display').textContent = val;
      if (seqPlaying) seqRestartInterval();
    });

    document.getElementById('seq-bpm-up').addEventListener('click', () => {
      const input = document.getElementById('seq-bpm');
      let val = parseInt(input.value) || 120;
      val = Math.min(300, val + 5);
      input.value = val;
      document.getElementById('seq-bpm-display').textContent = val;
      if (seqPlaying) seqRestartInterval();
    });

    document.getElementById('seq-volume').addEventListener('input', (e) => {
      document.getElementById('seq-volume-val').textContent = e.target.value;
      if (seqOutputGain) {
        seqOutputGain.gain.setTargetAtTime(parseInt(e.target.value) / 100, audioCtx.currentTime, 0.015);
      }
    });

    document.getElementById('seq-play').addEventListener('click', seqStart);
    document.getElementById('seq-stop').addEventListener('click', seqStop);
    document.getElementById('seq-reset').addEventListener('click', seqReset);

    drawSequencer();

    // Initial draw needs to wait for layout to complete so bounding client rect is accurate
    setTimeout(drawPiano, 0);
  </script>
</body>
</html>