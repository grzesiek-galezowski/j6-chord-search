<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chord Fun</title>
    <style>
    body {
      font-family: monospace;
      margin: 0;
      padding: 20px;
      background: #0f172a;
      color: #e5e7eb;
    }
    .back-link {
      display: inline-block;
      margin-bottom: 16px;
      font-size: 13px;
      color: #38bdf8;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }
    #container {
      font-size: 20px;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
    }
    .status {
      margin-bottom: 10px;
    }
    .piano-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
    }
    canvas {
      border: 1px solid black;
      background: #1e293b;
      max-width: 100%;
      touch-action: none;
    }
    #piano-control {
      width: 100%;
      max-width: 100%;
      height: 20vh;
      min-height: 120px;
    }
    #piano-play {
      width: 100%;
      max-width: 100%;
      height: 20vh;
      min-height: 120px;
    }
    .active-modes {
      color: #38bdf8;
      font-weight: bold;
    }
    .stepper-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .stepper {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .stepper button {
      width: 36px;
      height: 36px;
      background: #1e293b;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .stepper button:active {
      background: #38bdf8;
      color: #0f172a;
    }
    .stepper span {
      min-width: 24px;
      text-align: center;
      font-weight: bold;
    }
    .synth-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
      background: #1e293b;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: #0f172a;
      padding: 10px;
      border-radius: 6px;
      min-width: 200px;
    }
    .control-group h3 {
      margin: 0 0 5px 0;
      font-size: 16px;
      color: #38bdf8;
    }
    .control-group label {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .control-group input[type="range"] {
      width: 80px;
    }
    .control-group input[type="number"], .control-group select {
      width: 100px;
      background: #1e293b;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      padding: 2px 5px;
    }
    .val {
      display: inline-block;
      width: 30px;
      text-align: right;
      font-size: 12px;
      color: #94a3b8;
    }
    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      cursor: pointer;
    }
    #splash-screen h1 {
      color: #38bdf8;
      margin-bottom: 10px;
    }
    #splash-screen p {
      color: #e5e7eb;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      .control-group {
        min-width: 100%;
      }
      .synth-controls {
        gap: 10px;
      }
    }
    .sequencer-section {
      background: #1e293b;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      font-size: 14px;
    }
    .sequencer-section h3 {
      color: #38bdf8;
      margin: 0 0 12px 0;
      font-size: 16px;
    }
    .sequencer-header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }
    .sequencer-header > button {
      padding: 10px 18px;
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      cursor: pointer;
      font-family: monospace;
      font-size: 18px;
      line-height: 1;
    }
    .sequencer-header > button:active {
      background: #38bdf8;
      color: #0f172a;
    }
    #seq-play.active {
      background: #38bdf8;
      color: #0f172a;
    }
    #seq-record.active {
      background: #ef4444;
      color: white;
    }
    .seq-mode-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .seq-mode-group label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .sequencer-steps {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .seq-row {
      display: flex;
      gap: 4px;
      align-items: stretch;
    }
    .seq-row-steps {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
    }
    @media (min-width: 600px) {
      .seq-row-steps {
        grid-template-columns: repeat(8, 1fr);
      }
    }
    .seq-row-controls {
      display: flex;
      flex-direction: column;
      gap: 3px;
      justify-content: center;
      align-items: center;
      min-width: 28px;
    }
    .seq-row-controls > button {
      width: 24px;
      height: 20px;
      background: #0f172a;
      color: #94a3b8;
      border: 1px solid #334155;
      border-radius: 3px;
      cursor: pointer;
      font-family: monospace;
      font-size: 13px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .seq-row-controls > button:active {
      background: #38bdf8;
      color: #0f172a;
    }
    .seq-row-repeat {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
    }
    .seq-row-repeat button {
      width: 24px;
      height: 14px;
      background: #0f172a;
      color: #94a3b8;
      border: 1px solid #334155;
      border-radius: 2px;
      cursor: pointer;
      font-size: 8px;
      font-family: monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .seq-row-repeat button:active {
      background: #38bdf8;
      color: #0f172a;
    }
    .seq-row-repeat span {
      font-size: 11px;
      color: #e5e7eb;
      text-align: center;
      min-width: 16px;
      line-height: 1.2;
    }
    .seq-step {
      background: #0f172a;
      border: 2px solid #334155;
      border-radius: 6px;
      padding: 8px 4px;
      text-align: center;
      cursor: pointer;
      position: relative;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      user-select: none;
    }
    .seq-step.selected {
      border-color: #38bdf8;
    }
    .seq-step.playing {
      border-color: #fbbf24;
      background: #1a1500;
    }
    .seq-step.selected.playing {
      border-color: #f97316;
    }
    .seq-step-num {
      font-size: 10px;
      color: #64748b;
    }
    .seq-step-label {
      font-size: 11px;
      color: #e5e7eb;
      font-weight: bold;
      line-height: 1.3;
    }
    .seq-step-clear {
      position: absolute;
      top: 2px;
      right: 3px;
      width: 14px;
      height: 14px;
      font-size: 12px;
      background: transparent;
      border: none;
      color: #64748b;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }
    .seq-step-clear:hover {
      color: #ef4444;
    }
    .seq-step-empty {
      color: #475569;
      font-size: 18px;
    }
    .seq-vol-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
    }
    #seq-volume {
      width: 80px;
    }
    #seq-metro-res {
      background: #1e293b;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
      border-radius: 4px;
      padding: 2px 4px;
      font-family: monospace;
      font-size: 13px;
    }
    /* === Help Panel (desktop only) === */
    #help-panel {
      position: fixed;
      top: 10vh;
      bottom: 10vh;
      right: 0;
      display: flex;
      flex-direction: row;
      transform: translateX(calc(100% - 38px));
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 500;
    }
    #help-panel.open {
      transform: translateX(0);
    }
    @media (hover: none), (pointer: coarse) {
      #help-panel {
        display: none;
      }
    }
    #help-panel-content {
      width: 290px;
      overflow-y: auto;
      background: #1e293b;
      border: 1px solid #38bdf8;
      border-right: none;
      border-radius: 8px 0 0 8px;
      padding: 14px;
      color: #e5e7eb;
      font-size: 12px;
    }
    #help-panel-content h3 {
      margin: 0 0 6px 0;
      font-size: 13px;
      color: #38bdf8;
      border-bottom: 1px solid #334155;
      padding-bottom: 4px;
    }
    #help-panel-content h4 {
      margin: 10px 0 3px 0;
      font-size: 10px;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    #help-panel-tab {
      flex-shrink: 0;
      width: 38px;
      align-self: stretch;
      background: #38bdf8;
      color: #0f172a;
      border: none;
      cursor: pointer;
      font-family: monospace;
      font-weight: bold;
      font-size: 11px;
      writing-mode: vertical-rl;
      white-space: nowrap;
      user-select: none;
      letter-spacing: 0.05em;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #help-panel-tab:hover {
      background: #7dd3fc;
    }
    .help-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 4px;
    }
    .help-table td {
      padding: 2px 4px 2px 0;
      vertical-align: top;
      font-size: 11px;
      line-height: 1.4;
    }
    .help-table td:nth-child(odd) {
      color: #38bdf8;
      white-space: nowrap;
      padding-right: 6px;
      min-width: 28px;
    }
    .help-table td:nth-child(even) {
      color: #cbd5e1;
      padding-right: 10px;
    }
  </style>
</head>
<body>
<div id="splash-screen">
    <h1>Chord Fun</h1>
    <p>Click anywhere to start</p>
</div>
<a href="./index.html" class="back-link">← Back to Tools</a>
<div id="container">
    <div class="controls">
        <label>
            Preset:
            <select id="preset-selector">
                <option value="lush-pad">Lush Pad</option>
                <option value="plucky-synth">Plucky Synth</option>
                <option value="dirty-bass">Dirty Bass</option>
                <option value="soft-keys">Soft Keys</option>
                <option value="basic-triangle">Basic Triangle</option>
            </select>
        </label>
    </div>
    <div class="synth-controls">
        <div class="control-group">
            <h3>Oscillator</h3>
            <label>Waveform: 
                <select id="osc-wave">
                    <option value="triangle">Triangle</option>
                    <option value="sawtooth">Sawtooth</option>
                    <option value="square">Square</option>
                    <option value="sine">Sine</option>
                    <option value="organ">Organ</option>
                    <option value="brass">Brass</option>
                    <option value="bell">Bell</option>
                    <option value="voice">Voice</option>
                    <option value="pluck">Pluck</option>
                    <option value="soft-saw">Soft Saw</option>
                    <option value="hollow-square">Hollow Square</option>
                    <option value="metallic">Metallic</option>
                    <option value="sub-bass">Sub Bass</option>
                    <option value="harmonic-noise">Harmonic Noise</option>
                </select>
            </label>
            <label>Unison Voices: <input type="number" id="unison-voices" value="1" min="1" max="8" /></label>
            <label>Unison Detune: <input type="range" id="unison-detune" value="10" min="0" max="100" /><span class="val">10</span></label>
        </div>
        <div class="control-group">
            <h3>Amp Envelope</h3>
            <label>Attack: <input type="range" id="amp-a" value="10" min="0" max="2000" /><span class="val">10</span></label>
            <label>Decay: <input type="range" id="amp-d" value="100" min="0" max="2000" /><span class="val">100</span></label>
            <label>Sustain: <input type="range" id="amp-s" value="50" min="0" max="100" /><span class="val">50</span></label>
            <label>Release: <input type="range" id="amp-r" value="200" min="0" max="5000" /><span class="val">200</span></label>
        </div>
        <div class="control-group">
            <h3>Ladder Filter</h3>
            <label>Cutoff: <input type="range" id="filt-cutoff" value="2000" min="20" max="20000" /><span class="val">2000</span></label>
            <label>Resonance: <input type="range" id="filt-res" value="1" min="0.1" max="20" step="0.1" /><span class="val">1</span></label>
            <label>Drive: <input type="range" id="filt-drive" value="0" min="0" max="50" /><span class="val">0</span></label>
        </div>
        <div class="control-group">
            <h3>Filter Envelope</h3>
            <label>Amount: <input type="range" id="filt-env-amt" value="0" min="-10000" max="10000" /><span class="val">0</span></label>
            <label>Attack: <input type="range" id="filt-a" value="10" min="0" max="2000" /><span class="val">10</span></label>
            <label>Decay: <input type="range" id="filt-d" value="100" min="0" max="2000" /><span class="val">100</span></label>
            <label>Sustain: <input type="range" id="filt-s" value="50" min="0" max="100" /><span class="val">50</span></label>
            <label>Release: <input type="range" id="filt-r" value="200" min="0" max="5000" /><span class="val">200</span></label>
        </div>
    </div>
    <div class="controls">
        <div class="stepper-group">
            <label>Synth Octave Shift:</label>
            <div class="stepper">
                <button type="button" id="octave-down">-</button>
                <span id="octave-display">0</span>
                <button type="button" id="octave-up">+</button>
            </div>
            <input type="hidden" id="octave-shift" value="0" />
        </div>
        <label>
            Hold Mode:
            <input type="checkbox" id="hold-mode" />
        </label>
        <label>
            Root Doubling (-1 Oct):
            <input type="checkbox" id="root-doubling" checked />
        </label>
        <label>
            Strumming:
            <input type="checkbox" id="strumming" />
        </label>
    </div>
    <div class="status">
        <div>Active Chord Mode: <span id="active-chord" class="active-modes">None</span></div>
        <div>Active Extensions: <span id="active-exts" class="active-modes">None</span></div>
    </div>
    <div class="piano-container">
        <canvas id="piano-control" width="420" height="150"></canvas>
        <canvas id="piano-play" width="630" height="150"></canvas>
    </div>
    <div class="sequencer-section">
        <h3>Chord Sequencer</h3>
        <div class="sequencer-header">
            <div class="stepper">
                <button type="button" id="seq-bpm-down">-</button>
                <span>BPM:&nbsp;<span id="seq-bpm-display">120</span></span>
                <button type="button" id="seq-bpm-up">+</button>
            </div>
            <input type="hidden" id="seq-bpm" value="120" />
            <button type="button" id="seq-play" title="Play / Stop">&#9654;</button>
            <button type="button" id="seq-reset" title="Reset">&#8635;</button>
            <button type="button" id="seq-record" title="Record">&#9679;</button>
            <div class="seq-mode-group">
                <label><input type="radio" name="seq-mode" value="select" /> Select</label>
                <label><input type="radio" name="seq-mode" value="sh101" checked /> SH-101</label>
            </div>
            <label class="seq-vol-label">
                Vol: <input type="range" id="seq-volume" min="0" max="100" value="70" /><span class="val" id="seq-volume-val">70</span>
            </label>
            <label class="seq-vol-label">
                Metro: <input type="checkbox" id="seq-metronome" />
                <select id="seq-metro-res">
                    <option value="1">1 bar</option>
                    <option value="2">1/2</option>
                    <option value="4" selected>1/4</option>
                    <option value="8">1/8</option>
                    <option value="16">1/16</option>
                </select>
            </label>
        </div>
        <div id="sequencer-steps" class="sequencer-steps"></div>
    </div>
</div>
<div id="help-panel">
    <button id="help-panel-tab" title="Toggle keyboard shortcuts &amp; controls">&#9000;</button>
    <div id="help-panel-content">
        <h3>Keyboard Shortcuts</h3>
        <h4>Chord Modifiers</h4>
        <table class="help-table">
            <tr><td>z</td><td>Major</td></tr>
            <tr><td>s</td><td>Diminished</td></tr>
            <tr><td>x</td><td>Minor</td></tr>
            <tr><td>d</td><td>Suspended</td></tr>
            <tr><td>c</td><td>Inversion 1</td></tr>
            <tr><td>v</td><td>Inversion 2</td></tr>
            <tr><td>g</td><td>Ext: 6th</td></tr>
            <tr><td>b</td><td>Ext: m7</td></tr>
            <tr><td>h</td><td>Ext: M7</td></tr>
            <tr><td>n</td><td>Ext: 9th</td></tr>
        </table>
        <h4>Play — Octave 1 (C3–B3)</h4>
        <table class="help-table">
            <tr><td>q-u</td><td>C3-B3</td></tr>
        </table>
        <h4>Play — Octave 2 (C4–G4)</h4>
        <table class="help-table">
            <tr><td>i-]</td><td>C4-G4</td></tr>
        </table>
        <h4>Sequencer</h4>
        <table class="help-table">
            <tr><td>Space</td><td>Play / Stop sequencer</td></tr>
            <tr><td>&#8592;</td><td>Select prev step</td></tr>
            <tr><td>&#8594;</td><td>Select next step</td></tr>
            <tr><td>&#8593;</td><td>Select prev row</td></tr>
            <tr><td>&#8595;</td><td>Select next row</td></tr>
            <tr><td>Ctrl+&#8592;</td><td>Octave down</td></tr>
            <tr><td>Ctrl+&#8594;</td><td>Octave up</td></tr>
        </table>
        <h3> </h3>
        <h3>Controls</h3>
        <h4>Chord Engine</h4>
        <table class="help-table">
            <tr><td>Preset</td><td>Load synth preset</td></tr>
            <tr><td>Oct Shift</td><td>Transpose &#177;3 octaves</td></tr>
            <tr><td>Hold Mode</td><td>Latch modifiers; press again to toggle each</td></tr>
            <tr><td>Root Dbl</td><td>Add root one octave below</td></tr>
            <tr><td>Strumming</td><td>Guitar voicing + 30 ms note stagger</td></tr>
        </table>
        <h4>Sequencer</h4>
        <table class="help-table">
            <tr><td>BPM &#177;</td><td>Tempo 20–300 (step 5)</td></tr>
            <tr><td>&#9654;/&#9632;</td><td>Play / Stop (toggle)</td></tr>
            <tr><td>&#8635;</td><td>Stop + clear all steps</td></tr>
            <tr><td>&#9679; Rec</td><td>Toggle record (red = on)</td></tr>
            <tr><td>Select</td><td>Record to fixed selected step</td></tr>
            <tr><td>SH-101</td><td>Record + auto-advance step</td></tr>
            <tr><td>+</td><td>Add sequencer row</td></tr>
            <tr><td>&#9650;1&#9660;</td><td>Row repeat count</td></tr>
            <tr><td>Vol</td><td>Sequencer output level</td></tr>
            <tr><td>Metro</td><td>Metronome (playback only)</td></tr>
            <tr><td>Res</td><td>Metro density: 1 bar – 1/16</td></tr>
        </table>
        <h4>Synth Engine</h4>
        <table class="help-table">
            <tr><td>Waveform</td><td>Oscillator shape (14 types)</td></tr>
            <tr><td>Unison</td><td>Stacked voices + detune spread</td></tr>
            <tr><td>Amp Env</td><td>ADSR volume envelope</td></tr>
            <tr><td>Filter</td><td>Dual LP ladder; cutoff, Q, drive</td></tr>
            <tr><td>Filt Env</td><td>Cutoff ADSR sweep (&#177;10 kHz)</td></tr>
        </table>
    </div>
</div>
<script>
    // Audio Context
    let audioCtx = null;
    const activeOscillators = new Map(); // key: midiNote, value: array of voice objects
    const customWaves = {};
    const distortionCurveCache = new Map();
    const IS_MOBILE = ('ontouchstart' in window || navigator.maxTouchPoints > 0) &&
                      window.matchMedia('(pointer: coarse)').matches;

    function initCustomWaves(ctx) {
      customWaves['organ'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.8, 0.6, 0.1, 0.2, 0.1]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['brass'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['bell'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0, 0, 0.5, 0, 0, 0.2, 0, 0, 0.1]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['voice'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.2, 0.1, 0.05, 0.1, 0.2, 0.05]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['pluck'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.5, 0.25, 0.125, 0.06]),
        new Float32Array([0, 0, 0, 0, 0, 0])
      );
      customWaves['soft-saw'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.5, 0.33, 0.25, 0.2, 0.16, 0.14]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['hollow-square'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0, 0.33, 0, 0.2, 0, 0.14]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['metallic'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.1, 0.8, 0.2, 0.6, 0.3, 0.4]),
        new Float32Array([0, 0, 0, 0, 0, 0, 0, 0])
      );
      customWaves['sub-bass'] = ctx.createPeriodicWave(
        new Float32Array([0, 1, 0.3, 0.1, 0.05]),
        new Float32Array([0, 0, 0, 0, 0])
      );
      const noiseReal = new Float32Array(32);
      const noiseImag = new Float32Array(32);
      for(let i=1; i<32; i++) {
        noiseReal[i] = Math.random() * (1/i);
      }
      customWaves['harmonic-noise'] = ctx.createPeriodicWave(noiseReal, noiseImag);
    }

    function makeDistortionCurve(amount) {
      const k = typeof amount === 'number' ? amount : 50;
      if (distortionCurveCache.has(k)) return distortionCurveCache.get(k);
      const n_samples = 4096;
      const curve = new Float32Array(n_samples);
      const deg = Math.PI / 180;
      for (let i = 0; i < n_samples; ++i) {
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
      distortionCurveCache.set(k, curve);
      return curve;
    }

    const presets = {
      'lush-pad': {
        wave: 'soft-saw', unisonVoices: 4, unisonDetune: 25,
        ampA: 10, ampD: 1500, ampS: 70, ampR: 2000,
        filtCutoff: 800, filtRes: 2, filtDrive: 5,
        filtEnvAmt: 1500, filtA: 60, filtD: 2000, filtS: 50, filtR: 2000,
        octaveShift: -1
      },
      'plucky-synth': {
        wave: 'pluck', unisonVoices: 2, unisonDetune: 10,
        ampA: 10, ampD: 500, ampS: 0, ampR: 500,
        filtCutoff: 500, filtRes: 5, filtDrive: 10,
        filtEnvAmt: 4000, filtA: 10, filtD: 300, filtS: 0, filtR: 300,
        octaveShift: 0
      },
      'dirty-bass': {
        wave: 'sawtooth', unisonVoices: 3, unisonDetune: 15,
        ampA: 20, ampD: 800, ampS: 40, ampR: 400,
        filtCutoff: 200, filtRes: 8, filtDrive: 30,
        filtEnvAmt: 2000, filtA: 20, filtD: 500, filtS: 20, filtR: 400,
        octaveShift: -2
      },
      'soft-keys': {
        wave: 'sine', unisonVoices: 1, unisonDetune: 0,
        ampA: 50, ampD: 1000, ampS: 30, ampR: 1000,
        filtCutoff: 1200, filtRes: 1, filtDrive: 0,
        filtEnvAmt: 500, filtA: 50, filtD: 800, filtS: 30, filtR: 1000,
        octaveShift: 0
      },
      'basic-triangle': {
        wave: 'triangle', unisonVoices: 1, unisonDetune: 10,
        ampA: 10, ampD: 100, ampS: 50, ampR: 200,
        filtCutoff: 2000, filtRes: 1, filtDrive: 0,
        filtEnvAmt: 0, filtA: 10, filtD: 100, filtS: 50, filtR: 200,
        octaveShift: 0
      }
    };

    function applyPreset(presetName) {
      const p = presets[presetName];
      if (!p) return;

      document.getElementById('osc-wave').value = p.wave;
      document.getElementById('unison-voices').value = p.unisonVoices;

      const octShift = p.octaveShift !== undefined ? p.octaveShift : 0;
      document.getElementById('octave-shift').value = octShift;
      const octDisplay = document.getElementById('octave-display');
      if (octDisplay) octDisplay.innerText = octShift;

      const setRange = (id, val) => {
        const el = document.getElementById(id);
        el.value = val;
        const span = el.nextElementSibling;
        if (span && span.classList.contains('val')) span.innerText = val;
      };

      setRange('unison-detune', p.unisonDetune);
      setRange('amp-a', p.ampA);
      setRange('amp-d', p.ampD);
      setRange('amp-s', p.ampS);
      setRange('amp-r', p.ampR);
      setRange('filt-cutoff', p.filtCutoff);
      setRange('filt-res', p.filtRes);
      setRange('filt-drive', p.filtDrive);
      setRange('filt-env-amt', p.filtEnvAmt);
      setRange('filt-a', p.filtA);
      setRange('filt-d', p.filtD);
      setRange('filt-s', p.filtS);
      setRange('filt-r', p.filtR);
    }

    document.getElementById('preset-selector').addEventListener('change', (e) => {
      applyPreset(e.target.value);
    });

    document.getElementById('octave-down').addEventListener('click', () => {
      const input = document.getElementById('octave-shift');
      let val = parseInt(input.value) || 0;
      if (val > -3) {
        val--;
        input.value = val;
        document.getElementById('octave-display').innerText = val;
      }
    });

    document.getElementById('octave-up').addEventListener('click', () => {
      const input = document.getElementById('octave-shift');
      let val = parseInt(input.value) || 0;
      if (val < 3) {
        val++;
        input.value = val;
        document.getElementById('octave-display').innerText = val;
      }
    });

    // Apply default preset on load
    applyPreset('lush-pad');

    function getSynthParams() {
      return {
        wave: document.getElementById('osc-wave').value,
        unisonVoices: parseInt(document.getElementById('unison-voices').value),
        unisonDetune: parseFloat(document.getElementById('unison-detune').value),
        ampA: parseFloat(document.getElementById('amp-a').value) / 1000,
        ampD: parseFloat(document.getElementById('amp-d').value) / 1000,
        ampS: parseFloat(document.getElementById('amp-s').value) / 100,
        ampR: parseFloat(document.getElementById('amp-r').value) / 1000,
        filtCutoff: parseFloat(document.getElementById('filt-cutoff').value),
        filtRes: parseFloat(document.getElementById('filt-res').value),
        filtDrive: parseFloat(document.getElementById('filt-drive').value),
        filtEnvAmt: parseFloat(document.getElementById('filt-env-amt').value),
        filtA: parseFloat(document.getElementById('filt-a').value) / 1000,
        filtD: parseFloat(document.getElementById('filt-d').value) / 1000,
        filtS: parseFloat(document.getElementById('filt-s').value) / 100,
        filtR: parseFloat(document.getElementById('filt-r').value) / 1000,
      };
    }

    function initAudio() {
      if (!audioCtx) {
        const ctxOptions = IS_MOBILE ? { sampleRate: 22050 } : {};
        audioCtx = new (window.AudioContext || window.webkitAudioContext)(ctxOptions);
        initCustomWaves(audioCtx);
        seqOutputGain = audioCtx.createGain();
        seqOutputGain.gain.value = parseInt(document.getElementById('seq-volume').value) / 100;
        seqOutputGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    document.getElementById('splash-screen').addEventListener('click', (e) => {
      initAudio();
      e.currentTarget.style.display = 'none';
    });

    document.querySelectorAll('input[type="range"]').forEach(input => {
      input.addEventListener('input', (e) => {
        const span = e.target.nextElementSibling;
        if (span && span.classList.contains('val')) {
          span.innerText = e.target.value;
        }
      });
    });

    function midiToFreq(midiNote) {
      return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    function playFreqs(midiNote, freqs, destination = null, scheduleOffset = 0) {
      if (!audioCtx) return;
      const dest = destination || audioCtx.destination;
      const params = getSynthParams();
      const now = audioCtx.currentTime + scheduleOffset;
      const isStrumming = document.getElementById('strumming').checked;
      const strumDelay = isStrumming ? 0.03 : 0; // 30ms delay per note

      const voiceNodes = [];
      const maxGain = 0.5 / Math.max(1, Math.sqrt(freqs.length * params.unisonVoices));

      freqs.forEach((freq, index) => {
        const noteStartTime = now + (index * strumDelay);

        const driveNode = audioCtx.createWaveShaper();
        driveNode.curve = makeDistortionCurve(params.filtDrive);
        driveNode.oversample = IS_MOBILE ? 'none' : '4x';

        const filter1 = audioCtx.createBiquadFilter();
        filter1.type = 'lowpass';
        filter1.Q.value = params.filtRes;

        const filter2 = audioCtx.createBiquadFilter();
        filter2.type = 'lowpass';
        filter2.Q.value = params.filtRes;

        const ampNode = audioCtx.createGain();
        ampNode.gain.value = 0;

        driveNode.connect(filter1);
        filter1.connect(filter2);
        filter2.connect(ampNode);
        ampNode.connect(dest);

        ampNode.gain.setValueAtTime(0, noteStartTime);
        ampNode.gain.linearRampToValueAtTime(maxGain, noteStartTime + params.ampA);
        ampNode.gain.exponentialRampToValueAtTime(Math.max(0.0001, maxGain * params.ampS), noteStartTime + params.ampA + params.ampD);

        const baseCutoff = params.filtCutoff;
        const peakCutoff = Math.max(20, Math.min(20000, baseCutoff + params.filtEnvAmt));
        const sustainCutoff = Math.max(20, Math.min(20000, baseCutoff + params.filtEnvAmt * params.filtS));

        [filter1, filter2].forEach(f => {
          f.frequency.setValueAtTime(baseCutoff, noteStartTime);
          f.frequency.linearRampToValueAtTime(peakCutoff, noteStartTime + params.filtA);
          f.frequency.exponentialRampToValueAtTime(Math.max(20, sustainCutoff), noteStartTime + params.filtA + params.filtD);
        });

        const oscs = [];
        for (let i = 0; i < params.unisonVoices; i++) {
          const osc = audioCtx.createOscillator();

          if (['sine', 'square', 'sawtooth', 'triangle'].includes(params.wave)) {
            osc.type = params.wave;
          } else {
            osc.setPeriodicWave(customWaves[params.wave]);
          }

          let detune = 0;
          if (params.unisonVoices > 1) {
            const spread = params.unisonDetune;
            detune = (i / (params.unisonVoices - 1)) * spread * 2 - spread;
          }
          osc.frequency.value = freq;
          osc.detune.value = detune;

          osc.connect(driveNode);
          osc.start(noteStartTime);
          oscs.push(osc);
        }

        voiceNodes.push({ oscs, ampNode, filter1, filter2, params });
      });

      activeOscillators.set(midiNote, voiceNodes);
    }

    function stopFreqs(midiNote) {
      if (activeOscillators.has(midiNote)) {
        const voiceNodes = activeOscillators.get(midiNote);
        const now = audioCtx.currentTime;

        voiceNodes.forEach(voice => {
          const { oscs, ampNode, filter1, filter2, params } = voice;

          ampNode.gain.cancelScheduledValues(now);
          ampNode.gain.setValueAtTime(ampNode.gain.value, now);
          ampNode.gain.exponentialRampToValueAtTime(0.0001, now + params.ampR);

          const baseCutoff = params.filtCutoff;
          filter1.frequency.cancelScheduledValues(now);
          filter1.frequency.setValueAtTime(filter1.frequency.value, now);
          filter1.frequency.exponentialRampToValueAtTime(Math.max(20, baseCutoff), now + params.filtR);

          filter2.frequency.cancelScheduledValues(now);
          filter2.frequency.setValueAtTime(filter2.frequency.value, now);
          filter2.frequency.exponentialRampToValueAtTime(Math.max(20, baseCutoff), now + params.filtR);

          oscs.forEach(osc => {
            osc.stop(now + params.ampR + 0.1);
          });

          setTimeout(() => {
            oscs.forEach(osc => osc.disconnect());
            ampNode.disconnect();
          }, (params.ampR + 0.2) * 1000);
        });

        activeOscillators.delete(midiNote);
      }
    }

    // State
    const pressedNotes = new Set();
    const controlOctaveBase = 48; // C2
    
    // Control mappings
    const chordModes = {
      48: { name: 'Major', intervals: [0, 4, 7], guitarVoicing: [0, 7, 12, 16, 19, 24] },
      49: { name: 'Diminished', intervals: [0, 3, 6], guitarVoicing: [0, 6, 12, 15, 18, 24] },
      50: { name: 'Minor', intervals: [0, 3, 7], guitarVoicing: [0, 7, 12, 15, 19, 24] },
      51: { name: 'Suspended', intervals: [0, 5, 7], guitarVoicing: [0, 7, 12, 17, 19, 24] }
    };

    const chordInversions = {
      52: { name: 'Inv1', indexToRaise: 0 }, // E2
      53: { name: 'Inv2', indexToRaise: 1 }  // F2
    };

    const chordExtensions = {
      54: { name: '6', interval: 9 },   // F#2
      55: { name: 'm7', interval: 10 }, // G2
      56: { name: 'M7', interval: 11 }, // G#2
      57: { name: '9', interval: 14 }   // A2
    };

    let activeChordMode = null;
    const activeExtensions = new Set();
    const activeInversions = new Set();

    let latchedChordMode = null;
    const latchedExtensions = new Set();
    const latchedInversions = new Set();

    document.getElementById('hold-mode').addEventListener('change', (e) => {
      if (e.target.checked) {
        latchedChordMode = activeChordMode;
        latchedExtensions.clear();
        activeExtensions.forEach(ext => latchedExtensions.add(ext));
        latchedInversions.clear();
        activeInversions.forEach(inv => latchedInversions.add(inv));
      }
      updateState();
    });

    function updateState() {
      const isHold = document.getElementById('hold-mode').checked;

      if (!isHold) {
        activeChordMode = null;
        for (let key in chordModes) {
          if (pressedNotes.has(parseInt(key))) {
            activeChordMode = chordModes[key];
            break; // Only one active at a time
          }
        }

        activeExtensions.clear();
        for (let key in chordExtensions) {
          if (pressedNotes.has(parseInt(key))) {
            activeExtensions.add(chordExtensions[key]);
          }
        }

        activeInversions.clear();
        for (let key in chordInversions) {
          if (pressedNotes.has(parseInt(key))) {
            activeInversions.add(chordInversions[key]);
          }
        }
      } else {
        activeChordMode = latchedChordMode;
        activeExtensions.clear();
        latchedExtensions.forEach(e => activeExtensions.add(e));
        activeInversions.clear();
        latchedInversions.forEach(e => activeInversions.add(e));
      }

      document.getElementById('active-chord').innerText = activeChordMode ? activeChordMode.name : 'None';

      const exts = Array.from(activeExtensions).map(e => e.name);
      const invs = Array.from(activeInversions).map(e => e.name);
      const combined = [...exts, ...invs];

      document.getElementById('active-exts').innerText = combined.length > 0 
        ? combined.join(', ') 
        : 'None';

      drawPiano();
    }

    function getChordIntervals() {
      if (!activeChordMode) return [0];

      const isStrumming = document.getElementById('strumming').checked;
      let intervals = [];

      if (isStrumming && activeChordMode.guitarVoicing) {
        intervals = [...activeChordMode.guitarVoicing];
      } else {
        intervals = [...activeChordMode.intervals];
      }

      activeExtensions.forEach(ext => {
        // For guitar voicings, we might want to adjust extensions to fit, but for now just add them
        // usually extensions are added higher up
        let extInterval = ext.interval;
        if (isStrumming) {
           // push extensions up an octave to fit above the basic guitar voicing
           extInterval += 12;
        }
        intervals.push(extInterval);
      });

      // Apply inversions
      intervals.sort((a, b) => a - b);

      activeInversions.forEach(inv => {
        if (inv.indexToRaise < intervals.length) {
          intervals[inv.indexToRaise] += 12;
        }
      });

      // Add root doubling after inversions so it's not affected
      const isRootDoubling = document.getElementById('root-doubling').checked;
      if (isRootDoubling && !isStrumming) {
        intervals.push(-12);
      }

      return intervals;
    }

    // Piano drawing setup
    const canvasControl = document.getElementById('piano-control');
    const ctxControl = canvasControl.getContext('2d');
    const canvasPlay = document.getElementById('piano-play');
    const ctxPlay = canvasPlay.getContext('2d');

    const startNoteControl = 48; // C2
    const endNoteControl = 59;   // B2 (1 octave)
    const startNotePlay = 60;    // C3
    const endNotePlay = 83;      // B4 (2 octaves)

    // Base dimensions for drawing logic (will scale via CSS)
    const whiteKeyWidthControl = 60; // Wider for control
    const blackKeyWidthControl = 36;
    const blackKeyHeightControl = 90;
    const whiteKeyHeightControl = 150;
    const blackOffsetsControl = [60, 120, 240, 300, 360]; // Centers for C#, D#, F#, G#, A#

    const whiteKeyWidthPlay = 45; // Wider than original, but less than control
    const blackKeyWidthPlay = 27;
    const blackKeyHeightPlay = 90;
    const whiteKeyHeightPlay = 150;
    const blackOffsetsPlay = [45, 90, 180, 225, 270]; // Centers for C#, D#, F#, G#, A#

    function resizeCanvas(canvas, logicalWidth, logicalHeight) {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // Set actual size in memory (scaled to account for extra pixel density)
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      // Normalize coordinate system to use css pixels
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      // Scale to fit the logical dimensions into the actual dimensions
      const scaleX = rect.width / logicalWidth;
      const scaleY = rect.height / logicalHeight;
      ctx.scale(scaleX, scaleY);
    }

    let canvasNeedsResize = true;

    function drawPiano() {
      if (canvasNeedsResize) {
        resizeCanvas(canvasControl, 420, 150);
        resizeCanvas(canvasPlay, 630, 150);
        canvasNeedsResize = false;
      }

      // Draw Control Piano
      ctxControl.clearRect(0, 0, 420, 150);

      // Draw white keys (7 keys for 1 octave)
      for (let i = 0; i < 7; i++) {
        const x = i * whiteKeyWidthControl;
        const noteOffset = [0, 2, 4, 5, 7, 9, 11][i];
        const note = startNoteControl + noteOffset;

        let isActiveControl = false;
        if (chordModes[note] && activeChordMode === chordModes[note]) isActiveControl = true;
        if (chordExtensions[note] && activeExtensions.has(chordExtensions[note])) isActiveControl = true;
        if (chordInversions[note] && activeInversions.has(chordInversions[note])) isActiveControl = true;

        ctxControl.fillStyle = (pressedNotes.has(note) || isActiveControl) ? 'yellow' : '#e2e8f0';
        ctxControl.fillRect(x, 0, whiteKeyWidthControl, whiteKeyHeightControl);
        ctxControl.strokeRect(x, 0, whiteKeyWidthControl, whiteKeyHeightControl);

        // Label control keys
        ctxControl.fillStyle = 'black';
        ctxControl.font = '14px monospace';
        if (chordModes[note]) {
          ctxControl.fillText(chordModes[note].name.substring(0, 3), x + 5, whiteKeyHeightControl - 15);
        } else if (chordExtensions[note]) {
          ctxControl.fillText(chordExtensions[note].name, x + 10, whiteKeyHeightControl - 15);
        } else if (chordInversions[note]) {
          ctxControl.fillText(chordInversions[note].name, x + 5, whiteKeyHeightControl - 15);
        }
      }

      // Draw black keys (5 keys for 1 octave)
      const blackNotesControl = [1, 3, 6, 8, 10];
      for (let i = 0; i < 5; i++) {
        const note = startNoteControl + blackNotesControl[i];
        const x = blackOffsetsControl[i] - blackKeyWidthControl / 2;

        let isActiveControl = false;
        if (chordModes[note] && activeChordMode === chordModes[note]) isActiveControl = true;
        if (chordExtensions[note] && activeExtensions.has(chordExtensions[note])) isActiveControl = true;
        if (chordInversions[note] && activeInversions.has(chordInversions[note])) isActiveControl = true;

        ctxControl.fillStyle = (pressedNotes.has(note) || isActiveControl) ? 'yellow' : 'black';
        ctxControl.fillRect(x, 0, blackKeyWidthControl, blackKeyHeightControl);

        // Label control keys
        ctxControl.fillStyle = 'white';
        ctxControl.font = '12px monospace';
        if (chordModes[note]) {
          ctxControl.fillText(chordModes[note].name.substring(0, 3), x + 2, blackKeyHeightControl - 15);
        } else if (chordExtensions[note]) {
          ctxControl.fillText(chordExtensions[note].name, x + 5, blackKeyHeightControl - 15);
        } else if (chordInversions[note]) {
          ctxControl.fillText(chordInversions[note].name, x + 2, blackKeyHeightControl - 15);
        }
      }

      // Draw Play Piano
      ctxPlay.clearRect(0, 0, 630, 150);

      // Draw white keys (14 keys for 2 octaves)
      for (let i = 0; i < 14; i++) {
        const x = i * whiteKeyWidthPlay;
        const octave = Math.floor(i / 7);
        const noteIndex = i % 7;
        const noteOffset = [0, 2, 4, 5, 7, 9, 11][noteIndex];
        const note = startNotePlay + octave * 12 + noteOffset;

        if (note <= endNotePlay) {
          ctxPlay.fillStyle = pressedNotes.has(note) ? 'yellow' : 'white';
          ctxPlay.fillRect(x, 0, whiteKeyWidthPlay, whiteKeyHeightPlay);
          ctxPlay.strokeRect(x, 0, whiteKeyWidthPlay, whiteKeyHeightPlay);
        }
      }

      // Draw black keys (10 keys, 5 per octave for 2 octaves)
      for (let octave = 0; octave < 2; octave++) {
        const startX = (octave * 7 * whiteKeyWidthPlay);
        const blackNotesPlay = [1, 3, 6, 8, 10];
        for (let i = 0; i < 5; i++) {
          const note = startNotePlay + octave * 12 + blackNotesPlay[i];
          if (note <= endNotePlay) {
            const x = startX + blackOffsetsPlay[i] - blackKeyWidthPlay / 2;
            ctxPlay.fillStyle = pressedNotes.has(note) ? 'yellow' : 'black';
            ctxPlay.fillRect(x, 0, blackKeyWidthPlay, blackKeyHeightPlay);
          }
        }
      }
    }

    // MIDI setup
    if (navigator.requestMIDIAccess) {
      navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
    }

    function onMIDISuccess(midiAccess) {
      const inputs = midiAccess.inputs.values();
      for (let input of inputs) {
        input.onmidimessage = handleMIDIMessage;
      }
      drawPiano();
    }

    function onMIDIFailure() {
      console.error('Failed to access MIDI devices.');
    }

    function handleMIDIMessage(event) {
      const message = event.data;
      const type = message[0];
      const note = message[1];
      const velocity = message[2];
      
      if (type >= 144 && type <= 159 && velocity > 0) {
        noteOn(note);
      } else if ((type >= 128 && type <= 143) || (type >= 144 && type <= 159 && velocity === 0)) {
        noteOff(note);
      }
    }

    function noteOn(note) {
      initAudio();
      pressedNotes.add(note);

      if (note < controlOctaveBase + 12) {
        const isHold = document.getElementById('hold-mode').checked;
        if (isHold) {
          if (chordModes[note]) {
            if (latchedChordMode === chordModes[note]) {
              latchedChordMode = null;
            } else {
              latchedChordMode = chordModes[note];
            }
          } else if (chordExtensions[note]) {
            if (latchedExtensions.has(chordExtensions[note])) {
              latchedExtensions.delete(chordExtensions[note]);
            } else {
              latchedExtensions.add(chordExtensions[note]);
            }
          } else if (chordInversions[note]) {
            if (latchedInversions.has(chordInversions[note])) {
              latchedInversions.delete(chordInversions[note]);
            } else {
              latchedInversions.add(chordInversions[note]);
            }
          }
        }
      }

      updateState();

      // If it's a playing note (above control octave)
      if (note >= controlOctaveBase + 12) {
        const shift = parseInt(document.getElementById('octave-shift').value) || 0;
        const baseNote = note + (shift * 12);
        const intervals = getChordIntervals();
        const freqs = intervals.map(interval => midiToFreq(baseNote + interval));
        playFreqs(note, freqs);

        if (seqRecordMode) {
          seqRecordToStep(seqSelectedRow, seqSelectedStep, note);
          if (document.querySelector('input[name="seq-mode"]:checked').value === 'sh101') {
            seqAdvanceToNextStep();
          }
        }
      }
    }

    function noteOff(note) {
      pressedNotes.delete(note);
      updateState();
      
      if (note >= controlOctaveBase + 12) {
        stopFreqs(note);
      } else {
        // If a control key is released, we might want to update currently playing chords?
        // For simplicity, we only apply chord modes at the moment of noteOn.
      }
    }

    // Mouse interaction for piano
    function setupMouseEvents(canvas, isControl) {
      const logicalWidth = isControl ? 420 : 630;
      const logicalHeight = 150;

      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = logicalWidth / rect.width;
        const scaleY = logicalHeight / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        const note = getNoteFromPos(x, y, isControl);
        if (note !== null) {
          noteOn(note);
          canvas.dataset.activeNote = note;
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        const note = parseInt(canvas.dataset.activeNote);
        if (!isNaN(note)) {
          noteOff(note);
          delete canvas.dataset.activeNote;
        }
      });

      canvas.addEventListener('mouseleave', (e) => {
        const note = parseInt(canvas.dataset.activeNote);
        if (!isNaN(note)) {
          noteOff(note);
          delete canvas.dataset.activeNote;
        }
      });
    }

    setupMouseEvents(canvasControl, true);
    setupMouseEvents(canvasPlay, false);

    // Touch interaction for piano
    function setupTouchEvents(canvas, isControl) {
      const activeTouches = new Map();
      const logicalWidth = isControl ? 420 : 630;
      const logicalHeight = 150;

      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = logicalWidth / rect.width;
        const scaleY = logicalHeight / rect.height;

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.target !== canvas) continue;
          const x = (touch.clientX - rect.left) * scaleX;
          const y = (touch.clientY - rect.top) * scaleY;
          const note = getNoteFromPos(x, y, isControl);
          if (note !== null) {
            noteOn(note);
            activeTouches.set(touch.identifier, note);
          }
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = logicalWidth / rect.width;
        const scaleY = logicalHeight / rect.height;

        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.target !== canvas) continue;
          const x = (touch.clientX - rect.left) * scaleX;
          const y = (touch.clientY - rect.top) * scaleY;
          const currentNote = getNoteFromPos(x, y, isControl);
          const prevNote = activeTouches.get(touch.identifier);

          if (currentNote !== prevNote) {
            if (prevNote !== undefined && prevNote !== null) {
              noteOff(prevNote);
            }
            if (currentNote !== null) {
              noteOn(currentNote);
              activeTouches.set(touch.identifier, currentNote);
            } else {
              activeTouches.delete(touch.identifier);
            }
          }
        }
      }, { passive: false });

      const handleTouchEnd = (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.target !== canvas) continue;
          const note = activeTouches.get(touch.identifier);
          if (note !== undefined && note !== null) {
            noteOff(note);
            activeTouches.delete(touch.identifier);
          }
        }
      };

      canvas.addEventListener('touchend', handleTouchEnd);
      canvas.addEventListener('touchcancel', handleTouchEnd);
    }

    setupTouchEvents(canvasControl, true);
    setupTouchEvents(canvasPlay, false);

    // QWERTY Keyboard setup
    const keyToNote = {
      // Control octave
      'z': 48, 's': 49, 'x': 50, 'd': 51, 'c': 52, 'v': 53,
      'g': 54, 'b': 55, 'h': 56, 'n': 57, 'j': 58, 'm': 59,
      // Upper octaves
      'q': 60, '2': 61, 'w': 62, '3': 63, 'e': 64, 'r': 65,
      '5': 66, 't': 67, '6': 68, 'y': 69, '7': 70, 'u': 71,
      'i': 72, '9': 73, 'o': 74, '0': 75, 'p': 76, '[': 77,
      '=': 78, ']': 79
    };

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      if (e.ctrlKey && e.key === 'ArrowLeft') {
        e.preventDefault();
        document.getElementById('octave-down').click();
        return;
      }
      if (e.ctrlKey && e.key === 'ArrowRight') {
        e.preventDefault();
        document.getElementById('octave-up').click();
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (seqSelectedRow > 0) {
          seqSelectedRow--;
          seqRefreshAllClasses();
        }
        return;
      }
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (seqSelectedRow < sequencerRows.length - 1) {
          seqSelectedRow++;
          seqRefreshAllClasses();
        }
        return;
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        seqSelectedStep--;
        if (seqSelectedStep < 0) {
          seqSelectedStep = SEQ_STEPS - 1;
          seqSelectedRow = (seqSelectedRow - 1 + sequencerRows.length) % sequencerRows.length;
        }
        seqRefreshAllClasses();
        return;
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        seqSelectedStep++;
        if (seqSelectedStep >= SEQ_STEPS) {
          seqSelectedStep = 0;
          seqSelectedRow = (seqSelectedRow + 1) % sequencerRows.length;
        }
        seqRefreshAllClasses();
        return;
      }
      if (e.key === ' ') {
        e.preventDefault();
        seqToggle();
        return;
      }
      const key = e.key.toLowerCase();
      if (keyToNote[key] !== undefined) {
        noteOn(keyToNote[key]);
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      const key = e.key.toLowerCase();
      if (keyToNote[key] !== undefined) {
        noteOff(keyToNote[key]);
      }
    });

    function getNoteFromPos(x, y, isControl) {
      if (x < 0 || y < 0) return null;

      if (isControl) {
        if (x > 420 || y > 150) return null;
        // Check black keys first
        const blackNotesControl = [1, 3, 6, 8, 10];
        for (let i = 0; i < 5; i++) {
          const bx = blackOffsetsControl[i] - blackKeyWidthControl / 2;
          if (x >= bx && x <= bx + blackKeyWidthControl && y <= blackKeyHeightControl) {
            return startNoteControl + blackNotesControl[i];
          }
        }
        // Check white keys
        const whiteIndex = Math.floor(x / whiteKeyWidthControl);
        if (whiteIndex >= 0 && whiteIndex < 7) {
          const noteOffset = [0, 2, 4, 5, 7, 9, 11][whiteIndex];
          return startNoteControl + noteOffset;
        }
      } else {
        if (x > 630 || y > 150) return null;
        // Check black keys first
        for (let octave = 0; octave < 2; octave++) {
          const startX = (octave * 7 * whiteKeyWidthPlay);
          const blackNotesPlay = [1, 3, 6, 8, 10];
          for (let i = 0; i < 5; i++) {
            const bx = startX + blackOffsetsPlay[i] - blackKeyWidthPlay / 2;
            if (x >= bx && x <= bx + blackKeyWidthPlay && y <= blackKeyHeightPlay) {
              return startNotePlay + octave * 12 + blackNotesPlay[i];
            }
          }
        }
        // Check white keys
        const whiteIndex = Math.floor(x / whiteKeyWidthPlay);
        if (whiteIndex >= 0 && whiteIndex < 14) {
          const octave = Math.floor(whiteIndex / 7);
          const noteIndex = whiteIndex % 7;
          const noteOffset = [0, 2, 4, 5, 7, 9, 11][noteIndex];
          return startNotePlay + octave * 12 + noteOffset;
        }
      }
      return null;
    }

    window.addEventListener('resize', () => {
      canvasNeedsResize = true;
      drawPiano();
    });

    // === CHORD SEQUENCER ===
    const SEQ_STEPS = 8;
    const SEQ_KEY = 'seq';
    let sequencerRows = [{ steps: Array(SEQ_STEPS).fill(null), repeat: 1 }];
    let seqSelectedRow = 0;
    let seqSelectedStep = 0;
    let seqCurrentRow = 0;
    let seqCurrentStep = -1;
    let seqCurrentRowRepeat = 0;
    let seqIntervalId = null;
    let seqPlaying = false;
    let seqRecordMode = false;
    let seqCurrentFreqs = null;
    let seqOutputGain = null;

    function buildChordLabel(rootNote, chordMode, extensions, inversions) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const noteName = noteNames[rootNote % 12];
      const parts = [noteName];
      if (chordMode) parts.push(chordMode.name.substring(0, 3));
      if (extensions && extensions.size > 0) {
        parts.push(Array.from(extensions).map(e => e.name).join('+'));
      }
      if (inversions && inversions.size > 0) {
        parts.push(Array.from(inversions).map(e => e.name).join('+'));
      }
      return parts.join(' ');
    }

    function freqsMatch(a, b) {
      if (!a && !b) return true;
      if (!a || !b) return false;
      if (a.length !== b.length) return false;
      return a.every((f, i) => Math.abs(f - b[i]) < 0.01);
    }

    function seqRecordToStep(rowIndex, stepIndex, rootNote) {
      const shift = parseInt(document.getElementById('octave-shift').value) || 0;
      const baseNote = rootNote + (shift * 12);
      const intervals = getChordIntervals();
      const freqs = intervals.map(interval => midiToFreq(baseNote + interval));
      const label = buildChordLabel(rootNote, activeChordMode, activeExtensions, activeInversions);
      sequencerRows[rowIndex].steps[stepIndex] = { rootNote, label, freqs };
      seqRefreshStep(rowIndex, stepIndex);
    }

    function seqAdvanceToNextStep() {
      seqSelectedStep++;
      if (seqSelectedStep >= SEQ_STEPS) {
        seqSelectedStep = 0;
        seqSelectedRow = (seqSelectedRow + 1) % sequencerRows.length;
      }
      seqRefreshAllClasses();
    }

    function seqGetBarMs() {
      const bpm = parseInt(document.getElementById('seq-bpm').value) || 120;
      return (4 * 60 * 1000) / bpm;
    }

    function seqSetRecordMode(val) {
      seqRecordMode = val;
      document.getElementById('seq-record').classList.toggle('active', val);
    }

    function playMetronomeClick(time, accent) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = accent === 2 ? 1200 : accent === 1 ? 900 : 700;
      const amp = accent === 2 ? 0.4 : accent === 1 ? 0.25 : 0.15;
      gain.gain.setValueAtTime(amp, time);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(time);
      osc.stop(time + 0.08);
    }

    function seqScheduleMetronome(scheduleOffset = 0.005) {
      if (!audioCtx || !document.getElementById('seq-metronome').checked) return;
      const divisions = parseInt(document.getElementById('seq-metro-res').value) || 4;
      const barSec = seqGetBarMs() / 1000;
      const divSec = barSec / divisions;
      const now = audioCtx.currentTime + scheduleOffset;
      for (let i = 0; i < divisions; i++) {
        let accent;
        if (i === 0) {
          accent = 2;
        } else if ((i * 4) % divisions === 0) {
          accent = 1;
        } else {
          accent = 0;
        }
        playMetronomeClick(now + i * divSec, accent);
      }
    }

      function seqPlayCurrentStep() {
        const step = sequencerRows[seqCurrentRow].steps[seqCurrentStep];
        if (step !== null) {
          if (!freqsMatch(step.freqs, seqCurrentFreqs)) {
            if (seqCurrentFreqs !== null) {
              stopFreqs(SEQ_KEY);
            }
            playFreqs(SEQ_KEY, step.freqs, seqOutputGain, 0.05);
            seqCurrentFreqs = step.freqs;
          }
        } else {
          if (seqCurrentFreqs !== null) {
            stopFreqs(SEQ_KEY);
            seqCurrentFreqs = null;
          }
        }
        seqScheduleMetronome(0.05);
        seqRefreshAllClasses();
      }

      function seqAdvancePlayback() {
        seqCurrentStep++;
        if (seqCurrentStep >= SEQ_STEPS) {
          seqCurrentStep = 0;
          seqCurrentRowRepeat++;
          if (seqCurrentRowRepeat >= sequencerRows[seqCurrentRow].repeat) {
            seqCurrentRowRepeat = 0;
            seqCurrentRow = (seqCurrentRow + 1) % sequencerRows.length;
          }
        }
      }

      function seqRestartInterval() {
        if (seqIntervalId) clearInterval(seqIntervalId);
        seqIntervalId = setInterval(() => {
          seqAdvancePlayback();
          seqPlayCurrentStep();
        }, seqGetBarMs());
      }

      function seqToggle() {
        seqPlaying ? seqStop() : seqStart();
      }

      function seqStart() {
        if (seqPlaying) return;
        initAudio();
        seqSetRecordMode(false);
        seqPlaying = true;
        seqCurrentRow = 0;
        seqCurrentStep = 0;
        seqCurrentRowRepeat = 0;
        seqCurrentFreqs = null;
        seqPlayCurrentStep();
        seqRestartInterval();
        const btn = document.getElementById('seq-play');
        btn.classList.add('active');
        btn.innerHTML = '\u25A0';
      }

      function seqStop() {
        if (!seqPlaying) return;
        clearInterval(seqIntervalId);
        seqIntervalId = null;
        seqPlaying = false;
        seqSetRecordMode(false);
        if (seqCurrentFreqs !== null) {
          stopFreqs(SEQ_KEY);
          seqCurrentFreqs = null;
        }
        seqCurrentRow = 0;
        seqCurrentStep = -1;
        seqCurrentRowRepeat = 0;
        const btn = document.getElementById('seq-play');
        btn.classList.remove('active');
        btn.innerHTML = '\u25B6';
        seqRefreshAllClasses();
      }

    function seqReset() {
      seqStop();
      sequencerRows = [{ steps: Array(SEQ_STEPS).fill(null), repeat: 1 }];
      seqSelectedRow = 0;
      seqSelectedStep = 0;
      drawSequencer();
    }

    function seqAddRow(afterIndex) {
      const insertIndex = afterIndex !== undefined ? afterIndex + 1 : sequencerRows.length;
      sequencerRows.splice(insertIndex, 0, { steps: Array(SEQ_STEPS).fill(null), repeat: 1 });
      seqSelectedRow = insertIndex;
      seqSelectedStep = 0;
      drawSequencer();
    }

    function seqRemoveRow(rowIndex) {
      if (sequencerRows.length <= 1) return;
      sequencerRows.splice(rowIndex, 1);
      if (seqSelectedRow >= sequencerRows.length) seqSelectedRow = sequencerRows.length - 1;
      if (seqCurrentRow >= sequencerRows.length) seqCurrentRow = sequencerRows.length - 1;
      drawSequencer();
    }

    function seqChangeRepeat(rowIndex, delta) {
      const row = sequencerRows[rowIndex];
      row.repeat = Math.max(1, Math.min(99, row.repeat + delta));
      if (seqRowEls.length > rowIndex) {
        seqRowEls[rowIndex].repeatSpan.textContent = row.repeat;
      }
    }

    const seqRowEls = [];

    function initSequencerDOM() {
      const container = document.getElementById('sequencer-steps');
      container.innerHTML = '';
      seqRowEls.length = 0;

      sequencerRows.forEach((row, rowIdx) => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'seq-row';

        const stepsDiv = document.createElement('div');
        stepsDiv.className = 'seq-row-steps';

        const stepEls = [];
        for (let i = 0; i < SEQ_STEPS; i++) {
          const div = document.createElement('div');
          div.className = 'seq-step';

          const numSpan = document.createElement('span');
          numSpan.className = 'seq-step-num';
          numSpan.textContent = i + 1;
          div.appendChild(numSpan);

          const content = document.createElement('span');
          div.appendChild(content);

          const clearBtn = document.createElement('button');
          clearBtn.className = 'seq-step-clear';
          clearBtn.textContent = '\u00d7';
          clearBtn.title = 'Clear step';
          clearBtn.style.display = 'none';
          const ri = rowIdx, si = i;
          clearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            sequencerRows[ri].steps[si] = null;
            seqRefreshStep(ri, si);
          });
          div.appendChild(clearBtn);

          div.addEventListener('click', () => {
            seqSelectedRow = ri;
            seqSelectedStep = si;
            seqRefreshAllClasses();
          });

          stepsDiv.appendChild(div);
          stepEls.push({ div, content, clearBtn });
        }

        rowDiv.appendChild(stepsDiv);

        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'seq-row-controls';

        const addBtn = document.createElement('button');
        addBtn.textContent = '+';
        addBtn.title = 'Add row';
        addBtn.addEventListener('click', () => seqAddRow(rowIdx));
        controlsDiv.appendChild(addBtn);

        const repeatDiv = document.createElement('div');
        repeatDiv.className = 'seq-row-repeat';

        const upBtn = document.createElement('button');
        upBtn.textContent = '\u25B2';
        upBtn.title = 'Increase repeat';
        upBtn.addEventListener('click', () => seqChangeRepeat(rowIdx, 1));
        repeatDiv.appendChild(upBtn);

        const repeatSpan = document.createElement('span');
        repeatSpan.textContent = row.repeat;
        repeatDiv.appendChild(repeatSpan);

        const downBtn = document.createElement('button');
        downBtn.textContent = '\u25BC';
        downBtn.title = 'Decrease repeat';
        downBtn.addEventListener('click', () => seqChangeRepeat(rowIdx, -1));
        repeatDiv.appendChild(downBtn);

        controlsDiv.appendChild(repeatDiv);

        if (sequencerRows.length > 1) {
          const removeBtn = document.createElement('button');
          removeBtn.textContent = '\u00d7';
          removeBtn.title = 'Remove row';
          removeBtn.style.color = '#64748b';
          removeBtn.style.fontSize = '11px';
          removeBtn.addEventListener('click', () => seqRemoveRow(rowIdx));
          controlsDiv.appendChild(removeBtn);
        }

        rowDiv.appendChild(controlsDiv);
        container.appendChild(rowDiv);
        seqRowEls.push({ rowDiv, stepsDiv, steps: stepEls, repeatSpan });
      });
    }

    function seqRefreshStep(rowIdx, stepIdx) {
      if (seqRowEls.length === 0 || rowIdx >= seqRowEls.length) return;
      const { div, content, clearBtn } = seqRowEls[rowIdx].steps[stepIdx];
      div.classList.toggle('selected', rowIdx === seqSelectedRow && stepIdx === seqSelectedStep);
      div.classList.toggle('playing', seqPlaying && rowIdx === seqCurrentRow && stepIdx === seqCurrentStep);
      const step = sequencerRows[rowIdx].steps[stepIdx];
      if (step) {
        content.className = 'seq-step-label';
        content.textContent = step.label;
        clearBtn.style.display = '';
      } else {
        content.className = 'seq-step-empty';
        content.textContent = '\u2013';
        clearBtn.style.display = 'none';
      }
    }

    function seqRefreshAllClasses() {
      for (let r = 0; r < seqRowEls.length; r++) {
        for (let s = 0; s < SEQ_STEPS; s++) {
          const { div } = seqRowEls[r].steps[s];
          div.classList.toggle('selected', r === seqSelectedRow && s === seqSelectedStep);
          div.classList.toggle('playing', seqPlaying && r === seqCurrentRow && s === seqCurrentStep);
        }
      }
    }

    function drawSequencer() {
      initSequencerDOM();
      for (let r = 0; r < sequencerRows.length; r++) {
        for (let s = 0; s < SEQ_STEPS; s++) {
          seqRefreshStep(r, s);
        }
      }
    }

    document.getElementById('seq-bpm-down').addEventListener('click', () => {
      const input = document.getElementById('seq-bpm');
      let val = parseInt(input.value) || 120;
      val = Math.max(20, val - 5);
      input.value = val;
      document.getElementById('seq-bpm-display').textContent = val;
      if (seqPlaying) seqRestartInterval();
    });

    document.getElementById('seq-bpm-up').addEventListener('click', () => {
      const input = document.getElementById('seq-bpm');
      let val = parseInt(input.value) || 120;
      val = Math.min(300, val + 5);
      input.value = val;
      document.getElementById('seq-bpm-display').textContent = val;
      if (seqPlaying) seqRestartInterval();
    });

    document.getElementById('seq-volume').addEventListener('input', (e) => {
      document.getElementById('seq-volume-val').textContent = e.target.value;
      if (seqOutputGain) {
        seqOutputGain.gain.setTargetAtTime(parseInt(e.target.value) / 100, audioCtx.currentTime, 0.015);
      }
    });

    document.getElementById('seq-play').addEventListener('click', seqToggle);
    document.getElementById('seq-reset').addEventListener('click', seqReset);
    document.getElementById('seq-record').addEventListener('click', () => {
      seqSetRecordMode(!seqRecordMode);
    });

    drawSequencer();

    document.getElementById('help-panel-tab').addEventListener('click', () => {
      document.getElementById('help-panel').classList.toggle('open');
    });

    // Initial draw needs to wait for layout to complete so bounding client rect is accurate
    setTimeout(drawPiano, 0);
  </script>
</body>
</html>
